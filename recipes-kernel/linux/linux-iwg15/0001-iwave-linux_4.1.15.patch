diff --git a/arch/arm/boot/dts/Makefile b/arch/arm/boot/dts/Makefile
index 742a8f50856c..ca1349150511 100644
--- a/arch/arm/boot/dts/Makefile
+++ b/arch/arm/boot/dts/Makefile
@@ -344,7 +344,11 @@ dtb-$(CONFIG_SOC_IMX6Q) += \
 	imx6dqscm-1gb-evb-hdcp-fix-ldo.dtb \
 	imx6dqscm-1gb-qwks-rev3-fix-ldo.dtb \
 	imx6dqscm-1gb-qwks-rev3-hdcp-fix-ldo.dtb \
-	imx6dqscm-1gb-qwks-rev3-btwifi-fix-ldo.dtb
+	imx6dqscm-1gb-qwks-rev3-btwifi-fix-ldo.dtb \
+	imx6qd-iwg15m-sm_ldoactive.dtb \
+	imx6dls-iwg15m-sm_ldoactive.dtb \
+	imx6qd-iwg15m-sm_ldobypass.dtb \
+	imx6dls-iwg15m-sm_ldobypass.dtb
 dtb-$(CONFIG_SOC_IMX6SL) += \
 	imx6sl-evk.dtb \
 	imx6sl-evk-btwifi.dtb \
diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
index da1f292c4731..9994880c37b3 100644
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -703,6 +703,57 @@ config SOC_LS1021A
 
 endif
 
+menuconfig IWG15
+        bool "iWave RainboW G15 Platforms support"
+        depends on ARCH_MXC
+        select SOC_IMX6Q
+        select ARCH_HAS_CPUFREQ
+        select ARCH_HAS_OPP
+        select ARM_CPU_SUSPEND if PM
+        select ARM_ERRATA_754322
+        select ARM_ERRATA_764369 if SMP
+        select ARM_ERRATA_775420
+        select ARM_ERRATA_794072 if SMP
+        select ARM_ERRATA_761320 if SMP
+        select ARM_GIC
+        select COMMON_CLK
+        select CPU_V7
+        select HAVE_ARM_SCU if SMP
+        select HAVE_ARM_TWD if LOCAL_TIMERS
+        select HAVE_CAN_FLEXCAN if CAN
+        select HAVE_IMX_ANATOP
+        select HAVE_IMX_GPC
+        select HAVE_IMX_MMDC
+        select HAVE_IMX_SRC
+        select HAVE_SMP
+        select MFD_SYSCON
+        select MIGHT_HAVE_PCI
+        select PCI_DOMAINS if PCI
+        select ARCH_SUPPORTS_MSI
+        select PINCTRL
+        select PINCTRL_IMX6Q
+        select PL310_ERRATA_769419 if CACHE_PL310
+        select PM_OPP if PM
+        select ZONE_DMA
+        select SND_SOC_IMX_PCM_FIQ
+        select SND_SOC_IMX_PCM_DMA
+        select SND_SOC_IMX_AUDMUX
+        help
+          This enables support for iWave RainboW G15 Platforms based Freescale i.MX6 Quad/Dual/Dualite/Solo processor.
+
+choice
+        prompt "iWave RainboW G15 Platforms Selection"
+        depends on IWG15
+
+config IWG15M_SM
+        bool "iWave RainboW G15 SODIMM Platforms support"
+        depends on IWG15
+        help
+          This enables support for iWave RainboW G15 SODIMM Platforms based Freescale i.MX6 Quad/Dual/Dualite/Solo processor.
+
+endchoice
+
+
 source "arch/arm/mach-imx/devices/Kconfig"
 
 endif
diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile
index d47f4ac16c42..f885661a4011 100644
--- a/arch/arm/mach-imx/Makefile
+++ b/arch/arm/mach-imx/Makefile
@@ -43,6 +43,7 @@ AFLAGS_imx6sll_low_power_idle.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX6SLL) += cpuidle-imx6sll.o imx6sll_low_power_idle.o
 AFLAGS_imx7d_low_power_idle.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX7D) += cpuidle-imx7d.o imx7d_low_power_idle.o
+obj-$(CONFIG_IWG15) += mach-iwg15.o
 endif
 
 ifdef CONFIG_SND_IMX_SOC
diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c
index ad0897ac5832..aec9836ade94 100644
--- a/arch/arm/mach-imx/clk-imx6q.c
+++ b/arch/arm/mach-imx/clk-imx6q.c
@@ -804,6 +804,17 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_DI1_SEL], clk[IMX6QDL_CLK_IPU1_DI1_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI0_SEL], clk[IMX6QDL_CLK_IPU2_DI0_PRE]);
 	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_DI1_SEL], clk[IMX6QDL_CLK_IPU2_DI1_PRE]);
+#ifdef CONFIG_IWG15
+	/* IWG15: IPU: Added the below lines to fix for Frame buffer conflict with RGB LCD(fb0) & HDMI(fb2) */
+	imx_clk_set_rate(clk[IMX6QDL_CLK_PLL3_PFD1_540M], 540000000);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_SEL], clk[IMX6QDL_CLK_PLL3_PFD1_540M]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_AXI_ALT_SEL], clk[IMX6QDL_CLK_PLL3_PFD1_540M]);
+	imx_clk_set_parent(clk[IMX6QDL_CLK_AXI_SEL], clk[IMX6QDL_CLK_AXI_ALT_SEL]);
+	/* set epdc/pxp axi clock to 200Mhz */
+	imx_clk_set_parent(clk[IMX6QDL_CLK_IPU2_SEL], clk[IMX6QDL_CLK_PLL2_PFD2_396M]);
+	imx_clk_set_rate(clk[IMX6QDL_CLK_IPU2], 200000000);
+
+#else
 	if (cpu_is_imx6dl()) {
 		imx_clk_set_rate(clk[IMX6QDL_CLK_PLL3_PFD1_540M], 540000000);
 		imx_clk_set_parent(clk[IMX6QDL_CLK_IPU1_SEL], clk[IMX6QDL_CLK_PLL3_PFD1_540M]);
@@ -818,6 +829,7 @@ static void __init imx6q_clocks_init(struct device_node *ccm_node)
 		/* set eim_slow to 132Mhz */
 		imx_clk_set_rate(clk[IMX6QDL_CLK_EIM_SLOW], 132000000);
 	}
+#endif
 
 	/*
 	 * The gpmi needs 100MHz frequency in the EDO/Sync mode,
diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h
index 5c29916224ea..437d2eed9145 100644
--- a/arch/arm/mach-imx/common.h
+++ b/arch/arm/mach-imx/common.h
@@ -58,6 +58,9 @@ void mxc_set_cpu_type(unsigned int type);
 void mxc_set_arch_type(unsigned int type);
 void mxc_restart(enum reboot_mode, const char *);
 void mxc_arch_reset_init(void __iomem *);
+#ifdef CONFIG_IWG15
+void mxc_arch_reset_init_dt(void);
+#endif
 int mx51_revision(void);
 int mx53_revision(void);
 void imx_set_aips(void __iomem *);
diff --git a/arch/arm/mach-imx/mach-iwg15.c b/arch/arm/mach-imx/mach-iwg15.c
new file mode 100644
index 000000000000..2ae37ee42bbd
--- /dev/null
+++ b/arch/arm/mach-imx/mach-iwg15.c
@@ -0,0 +1,702 @@
+/*
+ * Copyright (c) 2017 iWave Systems Technologies Pvt. Ltd.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+
+#include <linux/can/platform/flexcan.h>
+#include <linux/clk.h>
+#include <linux/clkdev.h>
+#include <linux/cpu.h>
+#include <linux/delay.h>
+#include <linux/export.h>
+#include <linux/gpio.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/pm_opp.h>
+#include <linux/pci.h>
+#include <linux/phy.h>
+#include <linux/reboot.h>
+#include <linux/regmap.h>
+#include <linux/micrel_phy.h>
+#include <linux/mfd/syscon.h>
+#include <linux/mfd/syscon/imx6q-iomuxc-gpr.h>
+#include <linux/of_net.h>
+#include <linux/fec.h>
+#include <linux/netdevice.h>
+#include <linux/libata.h>
+#include <asm/mach/arch.h>
+#include <asm/mach/map.h>
+#include <asm/system_misc.h>
+
+#include "common.h"
+#include "cpuidle.h"
+#include "hardware.h"
+
+#define HW_OCOTP_CFGn(n)		(0x00000410 + (n) * 0x10)
+#define BSP_VERSION_PREPZ		"iW-PREPZ-SC-01-R3.0-REL1.0-Linux4.1.15"
+#define SOM_REV					1
+#define BOM_REV					2
+
+static struct flexcan_platform_data flexcan_pdata[2];
+static int flexcan0_en_gpio;
+static int flexcan1_en_gpio;
+
+static struct fec_platform_data fec_pdata;
+
+static void mmd_write_reg(struct phy_device *dev, int device, int reg, int val)
+{
+	phy_write(dev, 0x0d, device);
+	phy_write(dev, 0x0e, reg);
+	phy_write(dev, 0x0d, (1 << 14) | device);
+	phy_write(dev, 0x0e, val);
+}
+
+static int ksz9031_phy_fixup(struct phy_device *phydev)
+{
+	/* prefer master mode, 1000 Base-T capable */
+	phy_write(phydev, 0x9, 0x1f00);
+
+	/*
+	 * min rx data delay, max rx/tx clock delay,
+	 * min rx/tx control delay
+	 */
+	if(of_machine_is_compatible("iw,dls_iwg15m_sm") ||
+                        of_machine_is_compatible("iw,qd_iwg15m_sm")) {
+		mmd_write_reg(phydev, 2, 4, 0x80);
+		mmd_write_reg(phydev, 2, 5, 0x7787);
+		mmd_write_reg(phydev, 2, 6, 0);
+		mmd_write_reg(phydev, 2, 8, 0x03ff);
+	}
+
+	return 0;
+}
+
+static void __init imx6_iwg15_hdmi_cec_init (void)
+{
+	struct device_node *np;
+	int sm_hdmicec_gpio;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-hdmi-cec");
+	if (!np) {
+		pr_warn("failed to find g15-sm-hdmi node\n");
+		goto put_node;
+	}
+	sm_hdmicec_gpio = of_get_named_gpio(np, "hdmi-cec-sm-gpios", 0);
+	if (gpio_is_valid(sm_hdmicec_gpio) &&
+			!gpio_request_one(sm_hdmicec_gpio, GPIOF_DIR_OUT, "SM-HDMI-CEC")) {
+
+			gpio_set_value(sm_hdmicec_gpio, 1);
+	}
+put_node:
+        of_node_put(np);
+}
+
+static void __init sm_lvds_init (void)
+{
+	struct device_node *np;
+	int lcd_rst_gpio, lcd_pwr_gpio;
+
+	np = of_find_compatible_node(NULL, NULL, "iwave,g15-sm_lcd_pwr");
+	if (!np) {
+		pr_warn("failed to find g15-sm-lcd node\n");
+		goto put_node;
+	}
+
+	lcd_rst_gpio = of_get_named_gpio(np, "lcd-reset-gpios", 0);
+	if (gpio_is_valid(lcd_rst_gpio) &&
+			!gpio_request_one(lcd_rst_gpio, GPIOF_DIR_OUT, "lcd-reset GPIO")) {
+
+		gpio_set_value(lcd_rst_gpio, 1);
+		mdelay(100);
+		gpio_set_value(lcd_rst_gpio, 0);
+		mdelay(100);
+		gpio_set_value(lcd_rst_gpio, 1);
+	}
+
+	lcd_pwr_gpio = of_get_named_gpio(np, "lcd-power-gpios", 0);
+	if (gpio_is_valid(lcd_pwr_gpio) &&
+			!gpio_request_one(lcd_pwr_gpio, GPIOF_DIR_OUT, "lcd-power GPIO"))
+		gpio_set_value(lcd_pwr_gpio, 1);
+put_node:
+	of_node_put(np);
+}
+
+
+static void __init imx6_iwg15_common_reset (void)
+{
+	struct device_node *np;
+	int com_rst_gpio;
+
+		np = of_find_compatible_node(NULL, NULL, "iwave,g15-sm-com");
+		if (!np) {
+			pr_warn("failed to find g15-sm-com node\n");
+			goto put_node;
+		}
+	com_rst_gpio = of_get_named_gpio(np, "reset-gpios", 0);
+	if (gpio_is_valid(com_rst_gpio) &&
+			!gpio_request_one(com_rst_gpio, GPIOF_DIR_OUT, "comm-rst")) {
+
+		gpio_set_value(com_rst_gpio, 1);
+		mdelay(100);
+		gpio_set_value(com_rst_gpio, 0);
+		mdelay(100);
+		gpio_set_value(com_rst_gpio, 1);
+	}
+put_node:
+	of_node_put(np);
+}
+
+
+static int __init sm_som_revision (void)
+{
+        struct device_node *np;
+        int i,val,err,num_ctrl;
+        unsigned int *ctrl;
+        short revision = 0;
+
+        np = of_find_compatible_node(NULL, NULL, "iwave,g15-sm-com");
+        if (!np) {
+                pr_warn("failed to find g15-sm-com node\n");
+                revision =-1;
+                goto put_node;
+        }
+
+        /* Fill GPIO pin array */
+        num_ctrl = of_gpio_named_count(np, "som-rev-gpios");
+        if (num_ctrl <= 0) {
+                pr_warn("gpios DT property empty / missing\n");
+                revision =-1;
+                goto put_node;
+        }
+
+	ctrl = kzalloc(num_ctrl * sizeof(unsigned int), GFP_KERNEL);
+        if (!ctrl) {
+                pr_warn("unable to allocate the memory\n");
+                revision =-1;
+                goto put_node;
+        }
+        for (i = 0; i < num_ctrl; i++) {
+                val = of_get_named_gpio(np, "som-rev-gpios",i);
+
+               if (val < 0) {
+                        pr_warn("unable to get the gpio - %d\n", i);
+                        revision =-1;
+                        goto put_node;
+                }
+
+                ctrl[i] = val;
+        }
+        /* Request as a input GPIO and read the value */
+        for (i = 0; i < num_ctrl; i++) {
+		if (revision == 0x2)
+			continue;
+                err = gpio_request(ctrl[i],"som-rev-gpios");
+                if (err){
+                        pr_warn("unable to request for gpio - %d\n", i);
+                        revision =-1;
+                        goto put_node;
+                }
+
+                err = gpio_direction_input(ctrl[i]);
+                if (err) {
+                        pr_warn("unable to set gpio as input - %d\n", i);
+                        revision =-1;
+                        goto put_node;
+                }
+                revision |= gpio_get_value(ctrl[i]) << i;
+        }
+put_node:
+        of_node_put(np);
+        return revision;
+}
+
+static int __init sm_bom_revision (int som_ver)
+{
+        struct device_node *np1;
+        int i,val,err,num_ctrl,bit_shift=0;
+        unsigned *ctrl;
+        short revision = 0;
+
+	
+        np1 = of_find_compatible_node(NULL, NULL, "iwave,g15-sm-com");
+        if (!np1) {
+                pr_warn("failed to find g15-sm-com node\n");
+                revision =-1;
+                goto put_node;
+        }
+
+        /* Fill GPIO pin array */
+        num_ctrl = of_gpio_named_count(np1, "bom-rev-gpios");
+        if (num_ctrl <= 0) {
+                pr_warn("gpios DT property empty / missing\n");
+                revision =-1;
+                goto put_node;
+        }
+
+        ctrl = kzalloc(num_ctrl * sizeof(unsigned), GFP_KERNEL);
+        if (!ctrl) {
+                pr_warn("unable to allocate the memory\n");
+                revision =-1;
+                goto put_node;
+        }
+        for (i = 0; i < num_ctrl; i++) {
+                val = of_get_named_gpio(np1, "bom-rev-gpios",i);
+
+               if (val < 0) {
+                        pr_warn("unable to get the gpio - %d\n", i);
+                        revision =-1;
+                        goto put_node;
+                }
+
+                ctrl[i] = val;
+        }
+        /* Request as a input GPIO and read the value */
+
+        for (i=0; i < num_ctrl; i++) {
+		/* skip one bit in case of 3.0 SOM */
+		if (som_ver > 2) 
+		{
+			som_ver = 0;
+			bit_shift=1;
+			continue;
+		}
+
+                err = gpio_request(ctrl[i],"bom-rev-gpios");
+                if (err){
+                        pr_warn("unable to request for gpio - %d\n", i);
+                        revision =-1;
+                        goto put_node;
+                }
+
+                err = gpio_direction_input(ctrl[i]);
+                if (err) {
+                        pr_warn("unable to set gpio as input - %d\n", i);
+                        revision =-1;
+                        goto put_node;
+                }
+		if(bit_shift == 1)
+			/* skip one bit in case of 3.0 SOM */
+			revision |= gpio_get_value(ctrl[i]) << (i-1);
+		else
+			revision |= gpio_get_value(ctrl[i]) << i;
+
+        }
+put_node:
+        of_node_put(np1);
+        return revision;
+}
+
+static int __init print_board_info (void)
+{
+	struct device_node *np;
+	unsigned int unique_id1, unique_id2;
+	void __iomem *base;
+	int som_rev;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-ocotp");
+	if (!np) {
+		pr_warn("failed to find ocotp node\n");
+		return 0;
+	}
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_warn("failed to map ocotp\n");
+		goto put_node;
+	}
+
+	unique_id1 = readl_relaxed(base + HW_OCOTP_CFGn(0));
+	unique_id2 = readl_relaxed(base + HW_OCOTP_CFGn(1));
+
+	printk ("\n");
+	printk ("Board Info:\n");
+	printk ("\tBSP Version     : %s\n", BSP_VERSION_PREPZ);
+	som_rev = sm_som_revision()+1;	
+	printk ("\tSOM version     : iW-PREPZ-AP-01-R%1x.%1x\n",som_rev,sm_bom_revision(som_rev));
+	printk ("\tCPU Unique ID   : 0x%08x%08x \n", unique_id2, unique_id1);
+	printk ("\n");
+
+	iounmap(base);
+put_node:
+	of_node_put(np);
+	return 0;
+}
+
+static void imx6_iwg15_fec_sleep_enable(int enabled)
+{
+	struct regmap *gpr;
+
+	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
+	if (!IS_ERR(gpr)) {
+		if (enabled)
+			regmap_update_bits(gpr, IOMUXC_GPR13,
+					   IMX6Q_GPR13_ENET_STOP_REQ,
+					   IMX6Q_GPR13_ENET_STOP_REQ);
+		else
+			regmap_update_bits(gpr, IOMUXC_GPR13,
+					   IMX6Q_GPR13_ENET_STOP_REQ, 0);
+	} else
+		pr_err("failed to find fsl,imx6q-iomux-gpr regmap\n");
+}
+
+static void __init imx6_iwg15_enet_plt_init(void)
+{
+	struct device_node *np;
+
+	np = of_find_node_by_path("/soc/aips-bus@02100000/ethernet@02188000");
+	if (np && of_get_property(np, "fsl,magic-packet", NULL))
+		fec_pdata.sleep_mode_enable = imx6_iwg15_fec_sleep_enable;
+}
+
+static void __init imx6q_enet_phy_init(void)
+{
+	if (IS_BUILTIN(CONFIG_PHYLIB)) {
+		phy_register_fixup_for_uid(PHY_ID_KSZ9031, MICREL_PHY_ID_MASK,
+				ksz9031_phy_fixup);
+	}
+}
+
+static void __init imx6q_1588_init(void)
+{
+	struct device_node *np;
+	struct clk *ptp_clk;
+	struct regmap *gpr;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-fec");
+	if (!np) {
+		pr_warn("%s: failed to find fec node\n", __func__);
+		return;
+	}
+
+	ptp_clk = of_clk_get(np, 2);
+	if (IS_ERR(ptp_clk)) {
+		pr_warn("%s: failed to get ptp clock\n", __func__);
+		goto put_node;
+	}
+
+	/*
+	 * If enet_ref from ANATOP/CCM is the PTP clock source, we need to
+	 * set bit IOMUXC_GPR1[21].  Or the PTP clock must be from pad
+	 * (external OSC), and we need to clear the bit.
+	 */
+	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
+	if (!IS_ERR(gpr))
+		regmap_update_bits(gpr, IOMUXC_GPR1,
+				IMX6Q_GPR1_ENET_CLK_SEL_MASK,
+				IMX6Q_GPR1_ENET_CLK_SEL_ANATOP);
+	else
+		pr_err("failed to find fsl,imx6q-iomux-gpr regmap\n");
+
+	clk_put(ptp_clk);
+put_node:
+	of_node_put(np);
+}
+
+static void __init imx6q_axi_init(void)
+{
+	struct regmap *gpr;
+	unsigned int mask;
+
+	gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
+	if (!IS_ERR(gpr)) {
+		/*
+		 * Enable the cacheable attribute of VPU and IPU
+		 * AXI transactions.
+		 */
+		mask = IMX6Q_GPR4_VPU_WR_CACHE_SEL |
+			IMX6Q_GPR4_VPU_RD_CACHE_SEL |
+			IMX6Q_GPR4_VPU_P_WR_CACHE_VAL |
+			IMX6Q_GPR4_VPU_P_RD_CACHE_VAL_MASK |
+			IMX6Q_GPR4_IPU_WR_CACHE_CTL |
+			IMX6Q_GPR4_IPU_RD_CACHE_CTL;
+		regmap_update_bits(gpr, IOMUXC_GPR4, mask, mask);
+
+		/* Increase IPU read QoS priority */
+		regmap_update_bits(gpr, IOMUXC_GPR6,
+				IMX6Q_GPR6_IPU1_ID00_RD_QOS_MASK |
+				IMX6Q_GPR6_IPU1_ID01_RD_QOS_MASK,
+				(0xf << 16) | (0x7 << 20));
+		regmap_update_bits(gpr, IOMUXC_GPR7,
+				IMX6Q_GPR7_IPU2_ID00_RD_QOS_MASK |
+				IMX6Q_GPR7_IPU2_ID01_RD_QOS_MASK,
+				(0xf << 16) | (0x7 << 20));
+	} else {
+		pr_warn("failed to find fsl,imx6q-iomuxc-gpr regmap\n");
+	}
+}
+
+static void __init imx6q_enet_clk_sel(void)
+{
+        struct regmap *gpr;
+
+        gpr = syscon_regmap_lookup_by_compatible("fsl,imx6q-iomuxc-gpr");
+        if (!IS_ERR(gpr))
+                regmap_update_bits(gpr, IOMUXC_GPR5,
+                                   IMX6Q_GPR5_ENET_TX_CLK_SEL, IMX6Q_GPR5_ENET_TX_CLK_SEL);
+        else
+                pr_err("failed to find fsl,imx6q-iomux-gpr regmap\n");
+}
+
+static inline void imx6q_enet_init(void)
+{
+	imx6_enet_mac_init("fsl,imx6q-fec", "fsl,imx6q-ocotp");
+	imx6q_enet_phy_init();
+	imx6q_1588_init();
+	if (cpu_is_imx6q() && imx_get_soc_revision() == IMX_CHIP_REVISION_2_0)
+		imx6q_enet_clk_sel();
+	imx6_iwg15_enet_plt_init();
+}
+
+
+static void imx6_iwg15_flexcan0_switch_auto(int enable)
+{
+	/* Active low enables the CAN tranceiver */
+	if (enable)
+		gpio_set_value_cansleep(flexcan0_en_gpio, 0);
+	else
+		gpio_set_value_cansleep(flexcan0_en_gpio, 1);
+}
+
+static void imx6_iwg15_flexcan1_switch_auto(int enable)
+{
+	/* Active low enables the CAN tranceiver */
+	if (enable)
+		gpio_set_value_cansleep(flexcan1_en_gpio, 0);
+	else
+		gpio_set_value_cansleep(flexcan1_en_gpio, 1);
+}
+
+static int __init imx6_iwg15_flexcan_fixup_auto(void)
+{
+	struct device_node *can0,*can1;
+
+	can0 = of_find_node_by_path("/soc/aips-bus@02000000/flexcan@02090000");
+	if (!can0)
+		return -ENODEV;
+
+	flexcan0_en_gpio = of_get_named_gpio(can0, "trx-en-gpio", 0);
+	if (gpio_is_valid(flexcan0_en_gpio) &&
+			!gpio_request_one(flexcan0_en_gpio, GPIOF_DIR_OUT, "flexcan0-trx-en")) {
+		flexcan_pdata[0].transceiver_switch = imx6_iwg15_flexcan0_switch_auto;
+	}
+
+		can1 = of_find_node_by_path("/soc/aips-bus@02000000/flexcan@02094000");
+		if (!can1)
+			return -ENODEV;
+
+		flexcan1_en_gpio = of_get_named_gpio(can1, "trx-en-gpio", 0);
+		if (gpio_is_valid(flexcan1_en_gpio) &&
+				!gpio_request_one(flexcan1_en_gpio, GPIOF_DIR_OUT, "flexcan1-trx-en")) {
+			flexcan_pdata[1].transceiver_switch = imx6_iwg15_flexcan1_switch_auto;
+			of_node_put(can1);
+		}
+
+	return 0;
+}
+/* Add auxdata to pass platform data */
+static const struct of_dev_auxdata imx6_iwg15_auxdata_lookup[] __initconst = {
+	OF_DEV_AUXDATA("fsl,imx6q-flexcan", 0x02090000, NULL, &flexcan_pdata[0]),
+	OF_DEV_AUXDATA("fsl,imx6q-flexcan", 0x02094000, NULL, &flexcan_pdata[1]),
+	OF_DEV_AUXDATA("fsl,imx6q-fec", 0x02188000, NULL, &fec_pdata),
+	{ /* sentinel */ }
+};
+
+static void __init imx6q_init_machine(void)
+{
+	struct device *parent;
+
+	if (cpu_is_imx6dl()) {
+		if (num_online_cpus() == 2)
+			imx_print_silicon_rev("i.MX6DL", imx_get_soc_revision());
+		else
+			imx_print_silicon_rev("i.MX6S", imx_get_soc_revision());
+	} else if (cpu_is_imx6q() && imx_get_soc_revision() == IMX_CHIP_REVISION_2_0) {
+		if (num_online_cpus() == 4)
+			imx_print_silicon_rev("i.MX6QP", IMX_CHIP_REVISION_1_0);
+		else
+			imx_print_silicon_rev("i.MX6DP", IMX_CHIP_REVISION_1_0);
+	} else if (cpu_is_imx6q()) {
+		if (num_online_cpus() == 4)
+			imx_print_silicon_rev("i.MX6Q", imx_get_soc_revision());
+		else
+			imx_print_silicon_rev("i.MX6D", imx_get_soc_revision());
+	}
+
+	mxc_arch_reset_init_dt();
+
+	parent = imx_soc_device_init();
+	if (parent == NULL)
+		pr_warn("failed to initialize soc device\n");
+
+	of_platform_populate(NULL, of_default_bus_match_table,
+					imx6_iwg15_auxdata_lookup, parent);
+
+	imx6q_enet_init();
+	imx_anatop_init();
+	cpu_is_imx6q() ?  imx6q_pm_init() : imx6dl_pm_init();
+	imx6q_axi_init();
+	imx6_iwg15_common_reset();
+	sm_lvds_init();
+	imx6_iwg15_hdmi_cec_init();
+	print_board_info();
+}
+
+#define OCOTP_CFG3			0x440
+#define OCOTP_CFG3_SPEED_SHIFT		16
+#define OCOTP_CFG3_SPEED_1P2GHZ		0x3
+#define OCOTP_CFG3_SPEED_996MHZ		0x2
+#define OCOTP_CFG3_SPEED_852MHZ		0x1
+
+static void __init imx6q_opp_check_speed_grading(struct device *cpu_dev)
+{
+	struct device_node *np;
+	void __iomem *base;
+	u32 val;
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-ocotp");
+	if (!np) {
+		pr_warn("failed to find ocotp node\n");
+		return;
+	}
+
+	base = of_iomap(np, 0);
+	if (!base) {
+		pr_warn("failed to map ocotp\n");
+		goto put_node;
+	}
+
+	/*
+	 * SPEED_GRADING[1:0] defines the max speed of ARM:
+	 * 2b'11: 1200000000Hz;
+	 * 2b'10: 996000000Hz;
+	 * 2b'01: 852000000Hz; -- i.MX6Q Only, exclusive with 996MHz.
+	 * 2b'00: 792000000Hz;
+	 * We need to set the max speed of ARM according to fuse map.
+	 */
+	val = readl_relaxed(base + OCOTP_CFG3);
+	val >>= OCOTP_CFG3_SPEED_SHIFT;
+	val &= 0x3;
+
+	if ((val != OCOTP_CFG3_SPEED_1P2GHZ) && cpu_is_imx6q())
+		if (dev_pm_opp_disable(cpu_dev, 1200000000))
+			pr_warn("failed to disable 1.2 GHz OPP\n");
+	if (val < OCOTP_CFG3_SPEED_996MHZ)
+		if (dev_pm_opp_disable(cpu_dev, 996000000))
+			pr_warn("failed to disable 996 MHz OPP\n");
+	if (cpu_is_imx6q()) {
+		if (val != OCOTP_CFG3_SPEED_852MHZ)
+			if (dev_pm_opp_disable(cpu_dev, 852000000))
+				pr_warn("failed to disable 852 MHz OPP\n");
+	}
+	iounmap(base);
+
+	if (IS_ENABLED(CONFIG_MX6_VPU_352M)) {
+		if (dev_pm_opp_disable(cpu_dev, 396000000))
+			pr_warn("failed to disable 396MHz OPP\n");
+		pr_info("remove 396MHz OPP for VPU running at 352MHz!\n");
+	}
+
+put_node:
+	of_node_put(np);
+}
+
+static void __init imx6q_opp_init(void)
+{
+	struct device_node *np;
+	struct device *cpu_dev = get_cpu_device(0);
+
+	if (!cpu_dev) {
+		pr_warn("failed to get cpu0 device\n");
+		return;
+	}
+	np = of_node_get(cpu_dev->of_node);
+	if (!np) {
+		pr_warn("failed to find cpu0 node\n");
+		return;
+	}
+
+	if (of_init_opp_table(cpu_dev)) {
+		pr_warn("failed to init OPP table\n");
+		goto put_node;
+	}
+
+	imx6q_opp_check_speed_grading(cpu_dev);
+
+put_node:
+	of_node_put(np);
+}
+
+static struct platform_device imx6q_cpufreq_pdev = {
+	.name = "imx6q-cpufreq",
+};
+
+static void __init imx6q_init_late(void)
+{
+	/*
+	 * WAIT mode is broken on TO 1.0 and 1.1, so there is no point
+	 * to run cpuidle on them.
+	 */
+	if ((cpu_is_imx6q() && imx_get_soc_revision() > IMX_CHIP_REVISION_1_1)
+		|| (cpu_is_imx6dl() && imx_get_soc_revision() >
+		IMX_CHIP_REVISION_1_0))
+		imx6q_cpuidle_init();
+
+	if (IS_ENABLED(CONFIG_ARM_IMX6Q_CPUFREQ)) {
+		imx6q_opp_init();
+		platform_device_register(&imx6q_cpufreq_pdev);
+	}
+
+	imx6_iwg15_flexcan_fixup_auto();
+}
+
+static void __init imx6q_map_io(void)
+{
+	debug_ll_io_init();
+	imx_scu_map_io();
+	imx6_pm_map_io();
+	imx_busfreq_map_io();
+}
+
+static void __init imx6q_init_irq(void)
+{
+	imx_gpc_check_dt();
+	imx_init_revision_from_anatop();
+	imx_init_l2cache();
+	imx_src_init();
+	irqchip_init();
+}
+
+static const char * const imx6q_dt_compat[] __initconst = {
+	"iw,qd_iwg15m_sm",
+	"iw,dls_iwg15m_sm",
+	NULL,
+};
+
+DT_MACHINE_START(IMX6_IWG15, "iW-RainboW-G15 platform based on i.MX6 (Device Tree)")
+	/*
+	 * i.MX6Q/DL maps system memory at 0x10000000 (offset 256MiB), and
+	 * GPU has a limit on physical address that it accesses, which must
+	 * be below 2GiB.
+	 */
+	.dma_zone_size	= (SZ_2G - SZ_256M),
+	.smp		= smp_ops(imx_smp_ops),
+	.map_io		= imx6q_map_io,
+	.init_irq	= imx6q_init_irq,
+	.init_machine	= imx6q_init_machine,
+	.init_late      = imx6q_init_late,
+	.dt_compat	= imx6q_dt_compat,
+	.restart	= mxc_restart,
+MACHINE_END
diff --git a/arch/arm/mach-imx/system.c b/arch/arm/mach-imx/system.c
index 568d06e4ec62..919cafd368eb 100644
--- a/arch/arm/mach-imx/system.c
+++ b/arch/arm/mach-imx/system.c
@@ -34,6 +34,10 @@
 
 static void __iomem *wdog_base;
 static struct clk *wdog_clk;
+static u32 wdog_source = 1; /* use WDOG1 default */
+#ifdef CONFIG_IWG15
+extern void pfuze_core_val (void);
+#endif
 
 /*
  * Reset the system. It is called by machine_restart().
@@ -42,6 +46,27 @@ void mxc_restart(enum reboot_mode mode, const char *cmd)
 {
 	unsigned int wcr_enable;
 
+#ifdef CONFIG_IWG15
+	/* Increase the PMIC's SW1AB (VDDARM) voltage to 1.15 
+	   Otherwise system may not get to reboot in LDO bypass mode 
+	 */
+	if (of_machine_is_compatible("iw,qd_iwg15m_sm") || of_machine_is_compatible("iw,dls_iwg15m_sm"))
+	{
+		struct device_node *np;
+		u32 ldo_bypass;
+
+		np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");
+		if (!np) {
+			pr_warn("failed to find fsl,imx6q-gpc node\n");
+			of_node_put(np);
+		}
+		of_property_read_u32(np, "fsl,ldo-bypass", &ldo_bypass);
+
+		if (ldo_bypass)
+			pfuze_core_val ();
+	}
+#endif
+
 	if (!wdog_base)
 		goto reset_fallback;
 
@@ -89,6 +114,42 @@ void __init mxc_arch_reset_init(void __iomem *base)
 		clk_prepare(wdog_clk);
 }
 
+#ifdef CONFIG_IWG15
+void __init mxc_arch_reset_init_dt(void)
+{
+	struct device_node *np = NULL;
+
+	if (cpu_is_imx6q() || cpu_is_imx6dl())
+		np = of_find_compatible_node(NULL, NULL, "fsl,imx6q-gpc");
+	else if (cpu_is_imx6sl())
+		np = of_find_compatible_node(NULL, NULL, "fsl,imx6sl-gpc");
+
+	if (np)
+		of_property_read_u32(np, "fsl,wdog-reset", &wdog_source);
+	pr_info("Use WDOG%d as reset source\n", wdog_source);
+
+	np = of_find_compatible_node(NULL, NULL, "fsl,imx21-wdt");
+	wdog_base = of_iomap(np, 0);
+	WARN_ON(!wdog_base);
+
+	/* Some i.MX6 boards use WDOG2 to reset board in ldo-bypass mode */
+	if (wdog_source == 2 && (cpu_is_imx6q() || cpu_is_imx6dl() ||
+		cpu_is_imx6sl())) {
+		np = of_find_compatible_node(np, NULL, "fsl,imx21-wdt");
+		wdog_base = of_iomap(np, 0);
+		WARN_ON(!wdog_base);
+	}
+
+	wdog_clk = of_clk_get(np, 0);
+	if (IS_ERR(wdog_clk)) {
+		pr_warn("%s: failed to get wdog clock\n", __func__);
+		wdog_clk = NULL;
+		return;
+	}
+
+	clk_prepare(wdog_clk);
+}
+#endif
 #ifdef CONFIG_CACHE_L2X0
 void __init imx_init_l2cache(void)
 {
diff --git a/drivers/ata/ahci_imx.c b/drivers/ata/ahci_imx.c
index 3fccbed95ab2..bf784fa21106 100644
--- a/drivers/ata/ahci_imx.c
+++ b/drivers/ata/ahci_imx.c
@@ -371,7 +371,11 @@ static struct ata_port_operations ahci_imx_ops = {
 };
 
 static const struct ata_port_info ahci_imx_port_info = {
+#ifdef CONFIG_IWG15
+	.flags		= AHCI_FLAG_COMMON | ATA_FLAG_SW_ACTIVITY,
+#else
 	.flags		= AHCI_FLAG_COMMON,
+#endif
 	.pio_mask	= ATA_PIO4,
 	.udma_mask	= ATA_UDMA6,
 	.port_ops	= &ahci_imx_ops,
diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig
index caefe806db5e..dd6105698cdf 100644
--- a/drivers/gpio/Kconfig
+++ b/drivers/gpio/Kconfig
@@ -293,6 +293,12 @@ config GPIO_MXC
 	select GPIO_GENERIC
 	select GENERIC_IRQ_CHIP
 
+config RAINBOW_UNUSED_GPIO
+       tristate "iWave unused GPIO"
+       depends on OF_GPIO && IWG15 && GPIO_MXC
+       help
+         Say yes here to set the unused GPIOs as input in iW-RainboW-G15 platform.
+
 config GPIO_MXS
 	def_bool y
 	depends on ARCH_MXS
diff --git a/drivers/gpio/Makefile b/drivers/gpio/Makefile
index f71bb971329c..9c6b80b384eb 100644
--- a/drivers/gpio/Makefile
+++ b/drivers/gpio/Makefile
@@ -63,6 +63,7 @@ obj-$(CONFIG_GPIO_MSIC)		+= gpio-msic.o
 obj-$(CONFIG_GPIO_MSM_V2)	+= gpio-msm-v2.o
 obj-$(CONFIG_GPIO_MVEBU)        += gpio-mvebu.o
 obj-$(CONFIG_GPIO_MXC)		+= gpio-mxc.o
+obj-$(RAINBOW_UNUSED_GPIO)	+= gpio-unused.o
 obj-$(CONFIG_GPIO_MXS)		+= gpio-mxs.o
 obj-$(CONFIG_GPIO_OCTEON)	+= gpio-octeon.o
 obj-$(CONFIG_GPIO_OMAP)		+= gpio-omap.o
diff --git a/drivers/gpio/gpio-generic.c b/drivers/gpio/gpio-generic.c
index b92a690f5765..479325aec50c 100644
--- a/drivers/gpio/gpio-generic.c
+++ b/drivers/gpio/gpio-generic.c
@@ -139,7 +139,12 @@ static int bgpio_get(struct gpio_chip *gc, unsigned int gpio)
 {
 	struct bgpio_chip *bgc = to_bgpio_chip(gc);
 
+#ifdef CONFIG_IWG15
+	/* Parse the correct GPIO value */
+	return (bgc->read_reg(bgc->reg_dat) >> gpio) & 0x1;
+#else
 	return !!(bgc->read_reg(bgc->reg_dat) & bgc->pin2mask(bgc, gpio));
+#endif
 }
 
 static void bgpio_set(struct gpio_chip *gc, unsigned int gpio, int val)
diff --git a/drivers/gpio/gpio-unused.c b/drivers/gpio/gpio-unused.c
new file mode 100644
index 000000000000..33aa51e7772d
--- /dev/null
+++ b/drivers/gpio/gpio-unused.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2017 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; If not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+/*
+ * @file gpio-unused.c
+ *
+ * @brief Simple driver to set the unused GPIOs as input
+ *
+ * @ingroup GPIO
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+
+/* 
+ * iw_gpio_probe - Probe method for the GPIO device.
+ * @np: pointer to device tree node
+ *
+ * This function probes the Unused GPIOs in the device tree. It request GPIOs
+ * as input. It returns 0, if all the GPIOs is requested as input
+ * or a negative value if there is an error.
+ */
+static int iw_gpio_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	int i,val,err,num_ctrl;
+	unsigned *ctrl;
+
+	/* Fill GPIO pin array */
+	num_ctrl = of_gpio_count(np);
+	if (num_ctrl <= 0) {
+		dev_err(&pdev->dev, "gpios DT property empty / missing\n");
+		return -ENODEV;
+	}
+	ctrl = devm_kzalloc(&pdev->dev, num_ctrl * sizeof(unsigned),
+			GFP_KERNEL);
+	if (!ctrl)
+		return -ENOMEM;
+	for (i = 0; i < num_ctrl; i++) {
+
+		val = of_get_gpio(np, i);
+		if (val < 0)
+			return val;
+		ctrl[i] = val;
+	}
+
+	for (i = 0; i < num_ctrl; i++) {
+		err = devm_gpio_request(&pdev->dev, ctrl[i],
+				"Unused GPIOs as i/p");
+		if (err)
+			return err;
+
+		err = gpio_direction_input(ctrl[i]);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static int iw_gpio_remove(struct platform_device *pdev)
+{
+	/* Platform not registerd return silently */
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id iwgpio_match[] = {
+	{.compatible = "iwave,unused-gpios"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, iwgpio_match);
+#else
+#define iwgpio_match NULL
+#endif
+
+static struct platform_driver iwgpio_driver = {
+	.driver = {
+		.name   = "iw_gpio",
+		.owner  = THIS_MODULE,
+		.of_match_table = of_match_ptr(iwgpio_match),
+	},
+	.probe          = iw_gpio_probe,
+	.remove         = iw_gpio_remove,
+};
+
+static int __init iwgpio_init(void)
+{
+	return platform_driver_register(&iwgpio_driver);
+}
+subsys_initcall(iwgpio_init);
+
+static void __exit iwgpio_exit(void)
+{
+	platform_driver_unregister(&iwgpio_driver);
+}
+module_exit(iwgpio_exit);
+
+MODULE_AUTHOR("iWave Systems Technologies Pvt.Ltd");
+MODULE_DESCRIPTION("iWave unused GPIO Driver");
+MODULE_VERSION("0.1");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/input/touchscreen/stmpe-ts.c b/drivers/input/touchscreen/stmpe-ts.c
index e4c31256a74d..926c77b08d3b 100644
--- a/drivers/input/touchscreen/stmpe-ts.c
+++ b/drivers/input/touchscreen/stmpe-ts.c
@@ -63,6 +63,11 @@
 #define STMPE_TS_NAME			"stmpe-ts"
 #define XY_MASK				0xfff
 
+#ifdef CONFIG_IWG15
+#define STMPE_MIN_Y                    120
+#define STMPE_MAX_Y                   4210
+#endif
+
 struct stmpe_touch {
 	struct stmpe *stmpe;
 	struct input_dev *idev;
@@ -123,6 +128,18 @@ static void stmpe_work(struct work_struct *work)
 	input_sync(ts->idev);
 }
 
+#ifdef CONFIG_IWG15M_SM
+/* IWG15: TOUCH: Fix for touch calibration */
+static void calibration_pointer(int *x_orig, int *y_orig)
+{
+       int  y;
+
+        /*IWG15: TOUCH:( 100 / 93 )  is the scalling factor*/
+        y = ( *y_orig - STMPE_MIN_Y) * 100/93;
+        *y_orig = STMPE_MAX_Y - y;
+}
+#endif
+
 static irqreturn_t stmpe_ts_handler(int irq, void *data)
 {
 	u8 data_set[4];
@@ -149,7 +166,10 @@ static irqreturn_t stmpe_ts_handler(int irq, void *data)
 	x = (data_set[0] << 4) | (data_set[1] >> 4);
 	y = ((data_set[1] & 0xf) << 8) | data_set[2];
 	z = data_set[3];
-
+#ifdef CONFIG_IWG15
+        /* IWG15: TOUCH: Fix for touch calibration */
+       calibration_pointer(&x, &y);
+#endif
 	input_report_abs(ts->idev, ABS_X, x);
 	input_report_abs(ts->idev, ABS_Y, y);
 	input_report_abs(ts->idev, ABS_PRESSURE, z);
diff --git a/drivers/net/ethernet/freescale/fec_main.c b/drivers/net/ethernet/freescale/fec_main.c
index 2b1604113257..fea76938448f 100644
--- a/drivers/net/ethernet/freescale/fec_main.c
+++ b/drivers/net/ethernet/freescale/fec_main.c
@@ -980,6 +980,10 @@ fec_restart(struct net_device *ndev)
 		writel(0x0, fep->hwp + FEC_X_CNTRL);
 	}
 
+#ifdef FEC_FTRL
+       writel(PKT_MAXBUF_SIZE, fep->hwp + FEC_FTRL);
+#endif
+
 	/* Set MII speed */
 	writel(fep->phy_speed, fep->hwp + FEC_MII_SPEED);
 
diff --git a/drivers/regulator/pfuze100-regulator.c b/drivers/regulator/pfuze100-regulator.c
index e8099f4c2738..deba3fd4cbb9 100644
--- a/drivers/regulator/pfuze100-regulator.c
+++ b/drivers/regulator/pfuze100-regulator.c
@@ -129,7 +129,14 @@ static int pfuze100_set_ramp_delay(struct regulator_dev *rdev, int ramp_delay)
 	unsigned int ramp_bits;
 	int ret;
 
+#ifdef CONFIG_IWG15
+	/* The ramp delay is supported by only SW regulators and here 
+	 * SWBST not used so regulator id 6 will be assigned to VSNVS 
+	 */
+	if (id < PFUZE100_VSNVS) {
+#else
 	if (id < PFUZE100_SWBST) {
+#endif
 		ramp_delay = 12500 / ramp_delay;
 		ramp_bits = (ramp_delay >> 1) - (ramp_delay >> 3);
 		ret = regmap_update_bits(pfuze100->regmap,
@@ -310,15 +317,23 @@ static struct pfuze_regulator pfuze100_regulators[] = {
 	PFUZE100_SW_REG(PFUZE100, SW3A, PFUZE100_SW3AVOL, 400000, 1975000, 25000),
 	PFUZE100_SW_REG(PFUZE100, SW3B, PFUZE100_SW3BVOL, 400000, 1975000, 25000),
 	PFUZE100_SW_REG(PFUZE100, SW4, PFUZE100_SW4VOL, 400000, 1975000, 25000),
+#ifndef CONFIG_IWG15
 	PFUZE100_SWB_REG(PFUZE100, SWBST, PFUZE100_SWBSTCON1, 0x3 , pfuze100_swbst),
+#endif
 	PFUZE100_SWB_REG(PFUZE100, VSNVS, PFUZE100_VSNVSVOL, 0x7, pfuze100_vsnvs),
 	PFUZE100_FIXED_REG(PFUZE100, VREFDDR, PFUZE100_VREFDDRCON, 750000),
+#ifndef CONFIG_IWG15
 	PFUZE100_VGEN_REG(PFUZE100, VGEN1, PFUZE100_VGEN1VOL, 800000, 1550000, 50000),
+#endif
+#if !(defined(CONFIG_IWG15M_Q7) || defined(CONFIG_IWG15M_SM))
 	PFUZE100_VGEN_REG(PFUZE100, VGEN2, PFUZE100_VGEN2VOL, 800000, 1550000, 50000),
 	PFUZE100_VGEN_REG(PFUZE100, VGEN3, PFUZE100_VGEN3VOL, 1800000, 3300000, 100000),
+#endif
 	PFUZE100_VGEN_REG(PFUZE100, VGEN4, PFUZE100_VGEN4VOL, 1800000, 3300000, 100000),
 	PFUZE100_VGEN_REG(PFUZE100, VGEN5, PFUZE100_VGEN5VOL, 1800000, 3300000, 100000),
+#ifndef CONFIG_IWG15
 	PFUZE100_VGEN_REG(PFUZE100, VGEN6, PFUZE100_VGEN6VOL, 1800000, 3300000, 100000),
+#endif
 };
 
 static struct pfuze_regulator pfuze200_regulators[] = {
@@ -364,15 +379,23 @@ static struct of_regulator_match pfuze100_matches[] = {
 	{ .name = "sw3a",	},
 	{ .name = "sw3b",	},
 	{ .name = "sw4",	},
+#ifndef CONFIG_IWG15
 	{ .name = "swbst",	},
+#endif
 	{ .name = "vsnvs",	},
 	{ .name = "vrefddr",	},
+#ifndef CONFIG_IWG15
 	{ .name = "vgen1",	},
+#endif
+#if !(defined(CONFIG_IWG15M_Q7) || defined (CONFIG_IWG15M_SM))
 	{ .name = "vgen2",	},
 	{ .name = "vgen3",	},
+#endif
 	{ .name = "vgen4",	},
 	{ .name = "vgen5",	},
+#ifndef CONFIG_IWG15
 	{ .name = "vgen6",	},
+#endif
 };
 
 /* PFUZE200 */
@@ -485,6 +508,84 @@ static inline struct device_node *match_of_node(int index)
 }
 #endif
 
+#ifdef CONFIG_IWG15
+static struct i2c_client *pfuze_client;
+void pfuze_core_val (void);
+
+static int pfuze_read_reg(struct i2c_client *client,
+		u8 reg, u8 len, void *val)
+{
+	struct i2c_msg xfer[2];
+	u8 buf[1];
+	int ret;
+
+	buf[0] = reg & 0xff;
+
+	/* Write register */
+	xfer[0].addr = client->addr;
+	xfer[0].flags = 0;
+	xfer[0].len = 1;
+	xfer[0].buf = buf;
+
+	/* Read data */
+	xfer[1].addr = client->addr;
+	xfer[1].flags = I2C_M_RD;
+	xfer[1].len = len;
+	xfer[1].buf = val;
+
+	ret = i2c_transfer(client->adapter, xfer, 2);
+	if (ret == 2) {
+		ret = 0;
+	} else {
+		if (ret >= 0)
+			ret = -EIO;
+		dev_err(&client->dev, "%s: i2c transfer failed (%d)\n",
+				__func__, ret);
+	}
+
+	return ret;
+}
+
+static int pfuze_write_reg(struct i2c_client *client, u8 reg, u8 len,
+		const void *val)
+{
+	u8 *buf;
+	size_t count;
+	int ret;
+
+	count = len + 1;
+	buf = kmalloc(count, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	buf[0] = reg & 0xff;
+	memcpy(&buf[1], val, len);
+
+	ret = i2c_master_send(client, buf, count);
+	if (ret == count) {
+		ret = 0;
+	} else {
+		if (ret >= 0)
+			ret = -EIO;
+		dev_err(&client->dev, "%s: i2c send failed (%d)\n",
+				__func__, ret);
+	}
+
+	kfree(buf);
+	return ret;
+}
+
+void pfuze_core_val (void)
+{
+	u8 val;
+	/* Read the PMIC's SW1AB (VDDARM) value and increase to 1.15V */
+	pfuze_read_reg (pfuze_client, PFUZE100_SW1ABVOL, 1, &val);
+	val  = (val & 0xC0) | 0x22;
+	pfuze_write_reg (pfuze_client, PFUZE100_SW1ABVOL, 1, &val);
+
+}
+#endif
+
 static int pfuze_identify(struct pfuze_chip *pfuze_chip)
 {
 	unsigned int value;
@@ -573,6 +674,10 @@ static int pfuze100_regulator_probe(struct i2c_client *client,
 		return ret;
 	}
 
+#ifdef CONFIG_IWG15
+	/* save the client address for increasing SW1AB voltage */
+	pfuze_client = client;
+#endif
 	ret = pfuze_identify(pfuze_chip);
 	if (ret) {
 		dev_err(&client->dev, "unrecognized pfuze chip ID!\n");
diff --git a/drivers/thermal/imx_thermal.c b/drivers/thermal/imx_thermal.c
index fa8151882f87..ea515c3a6a78 100644
--- a/drivers/thermal/imx_thermal.c
+++ b/drivers/thermal/imx_thermal.c
@@ -106,6 +106,9 @@ enum imx_thermal_trip {
 #define TEMPMON_IMX6Q			1
 #define TEMPMON_IMX6SX			2
 #define TEMPMON_IMX7			3
+#ifdef CONFIG_IWG15
+#define OCOTP_MEM0                      0x0480
+#endif
 
 /* the register offsets and bitfields may change across
  * i.MX SOCs, use below struct as a description of the
@@ -232,6 +235,9 @@ struct imx_thermal_data {
 	struct clk *thermal_clk;
 	struct mutex mutex;
 	const struct thermal_soc_data *socdata;
+#ifdef CONFIG_IWG15
+        const char *temp_grade;
+#endif
 };
 
 static struct imx_thermal_data *imx_thermal_data;
@@ -620,7 +626,41 @@ static int imx_get_sensor_data(struct platform_device *pdev)
 		imx7_calibrate_data(data, val);
 	else
 		imx6_calibrate_data(data, val);
+#ifdef CONFIG_IWG15
+	/*Added to set the critical and passive tmperature based on temperature grading value*/
+	/* use OTP for thermal grade */
+	ret = regmap_read(map, OCOTP_MEM0, &val);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to read temp grade: %d\n", ret);
+		return ret;
+	}
+
+	/* The maximum die temp is specified by the Temperature Grade */
+	switch (val >> 6) {
+		case 0: /* Commercial (0 to 95C) */
+			data->temp_grade = "Commercial";
+			data->temp_passive = 75000;
+			break;
+		case 1: /* Extended Commercial (-20 to 105C) */
+			data->temp_grade = "Extended Commercial";
+			data->temp_passive = 85000;
+			break;
+		case 2: /* Industrial (-40 to 105C) */
+			data->temp_grade = "Industrial";
+			data->temp_passive = 85000;
+			break;
+		case 3: /* Automotive (-40 to 125C) */
+			data->temp_grade = "Automotive";
+			data->temp_passive = 100000;
+			break;
+	}
 
+ 	/*
+	 * Set the default critical trip point to 20 C higher
+	 * than passive trip point. Can be changed from userspace.
+	 */
+	data->temp_critical = data->temp_passive + 10 * 1000;
+#else
 	/*
 	 * Set the default passive cooling trip point to IMX_TEMP_PASSIVE.
 	 * Can be changed from userspace.
@@ -628,11 +668,12 @@ static int imx_get_sensor_data(struct platform_device *pdev)
 	data->temp_passive = IMX_TEMP_PASSIVE;
 
 	/*
-	 * Set the default critical trip point to 20 C higher
+	 * Set the default critical trip point to 10 C higher
 	 * than passive trip point. Can be changed from userspace.
 	 */
 	data->temp_critical = IMX_TEMP_PASSIVE + 20 * 1000;
 
+#endif
 	return 0;
 }
 
diff --git a/drivers/video/fbdev/mxc/Kconfig b/drivers/video/fbdev/mxc/Kconfig
index 3650a538d5ff..fe59bb0c5581 100644
--- a/drivers/video/fbdev/mxc/Kconfig
+++ b/drivers/video/fbdev/mxc/Kconfig
@@ -96,3 +96,9 @@ config FB_MXC_EINK_V2_PANEL
 config FB_MXC_EINK_AUTO_UPDATE_MODE
 	bool "E-Ink Auto-update Mode Support"
 	depends on FB_MXC_EINK_PANEL
+
+config IWG15_BACKLIGHT
+       tristate "iWave RainboW G15 backlight control"
+       depends on IWG15 && MXC_IPU_V3
+       help
+         Say yes here to control the LVDS backlight and power control in iW-RainboW-G15 platform.
diff --git a/drivers/video/fbdev/mxc/Makefile b/drivers/video/fbdev/mxc/Makefile
index dafc050f6b31..48468cbe37a1 100644
--- a/drivers/video/fbdev/mxc/Makefile
+++ b/drivers/video/fbdev/mxc/Makefile
@@ -4,6 +4,7 @@ obj-$(CONFIG_FB_MXC_TRULY_WVGA_SYNC_PANEL)      += mxcfb_hx8369_wvga.o
 obj-$(CONFIG_FB_MXC_TRULY_PANEL_TFT3P5079E)     += mxcfb_otm8018b_wvga.o
 obj-$(CONFIG_FB_MXC_TRULY_PANEL_TFT3P5581E)	+= mxcfb_hx8363_wvga.o
 obj-$(CONFIG_FB_MXC_LDB) += ldb.o
+obj-$(CONFIG_IWG15_BACKLIGHT) += iwg15_backlight.o
 obj-$(CONFIG_FB_MXC_HDMI)			+= mxc_hdmi.o
 obj-$(CONFIG_FB_MXC_EDID)			+= mxc_edid.o
 obj-$(CONFIG_FB_MXC_SYNC_PANEL) += mxc_dispdrv.o mxc_lcdif.o mxc_ipuv3_fb.o
diff --git a/drivers/video/fbdev/mxc/iwg15_backlight.c b/drivers/video/fbdev/mxc/iwg15_backlight.c
new file mode 100644
index 000000000000..d6142389a76c
--- /dev/null
+++ b/drivers/video/fbdev/mxc/iwg15_backlight.c
@@ -0,0 +1,252 @@
+/*
+ * Copyright (c) 2014-2015 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; If not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+/*
+ * @file iwg15_backlight.c
+ *
+ * @brief Simple driver to control the LVDS port power and backlight
+ *
+ * @ingroup MXC
+ */
+
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+#include <linux/err.h>
+#include <linux/gpio.h>
+#include <linux/of_platform.h>
+#include <linux/of_gpio.h>
+
+struct imx6_iwg15_backlight {
+        int                     power_on_gpio;
+        int                     backlght_on_gpio;
+};
+
+static int backlight_ctrl_state (struct imx6_iwg15_backlight *iwg15_backlight)
+{
+	int ret;
+        if (gpio_is_valid(iwg15_backlight->backlght_on_gpio))
+                ret = gpio_get_value(iwg15_backlight->backlght_on_gpio);
+	return ret;
+}
+
+static void backlight_ctrl (struct imx6_iwg15_backlight *iwg15_backlight, int val)
+{
+	if (gpio_is_valid(iwg15_backlight->backlght_on_gpio))
+		gpio_set_value(iwg15_backlight->backlght_on_gpio, val);
+}
+
+static int power_ctrl_state (struct imx6_iwg15_backlight *iwg15_backlight)
+{
+	int ret;
+        if (gpio_is_valid(iwg15_backlight->power_on_gpio))
+                ret = gpio_get_value(iwg15_backlight->power_on_gpio);
+	return ret;
+
+}
+
+static void power_ctrl (struct imx6_iwg15_backlight *iwg15_backlight, int val)
+{
+	if (gpio_is_valid(iwg15_backlight->power_on_gpio)) 
+		gpio_set_value(iwg15_backlight->power_on_gpio, val);
+
+}
+
+static ssize_t iwg15_backlight_ctrl_state(struct device *dev,
+                struct device_attribute *attr, const char *buf)
+{
+        struct imx6_iwg15_backlight *iwg15_backlight = dev_get_drvdata(dev);
+        int state;
+
+        state = backlight_ctrl_state(iwg15_backlight);
+
+	return sprintf(buf, "%d\n", state);
+}
+
+static ssize_t iwg15_backlight_ctrl(struct device *dev,
+                struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct imx6_iwg15_backlight *iwg15_backlight = dev_get_drvdata(dev);
+        unsigned long value;
+        int ret = 0;
+
+        ret = kstrtoul(buf, 2, &value);
+        if (ret)
+                return ret;
+
+	backlight_ctrl(iwg15_backlight, value);
+
+        return count;
+}
+
+static DEVICE_ATTR(bklight_enable, S_IWUSR | S_IRUGO, iwg15_backlight_ctrl_state, iwg15_backlight_ctrl);
+
+static ssize_t iwg15_backlight_power_ctrl_state(struct device *dev,
+                struct device_attribute *attr, const char *buf)
+{
+        struct imx6_iwg15_backlight *iwg15_backlight = dev_get_drvdata(dev);
+        int state;
+
+        state = power_ctrl_state(iwg15_backlight);
+
+	return sprintf(buf, "%d\n", state);
+}
+
+static ssize_t iwg15_backlight_power_ctrl(struct device *dev,
+                struct device_attribute *attr, const char *buf, size_t count)
+{
+	struct imx6_iwg15_backlight *iwg15_backlight = dev_get_drvdata(dev);
+        unsigned long value;
+        int ret = 0;
+
+        ret = kstrtoul(buf, 2, &value);
+        if (ret)
+                return ret;
+
+	power_ctrl(iwg15_backlight, value);
+
+        return count;
+}
+
+static DEVICE_ATTR(pwr_enable, S_IWUSR | S_IRUGO, iwg15_backlight_power_ctrl_state, iwg15_backlight_power_ctrl);
+
+#ifdef CONFIG_PM
+static int iwg15_backlight_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	struct imx6_iwg15_backlight *iwg15_backlight = dev_get_drvdata(&pdev->dev);
+
+	backlight_ctrl(iwg15_backlight, 0);
+	power_ctrl(iwg15_backlight, 0);
+
+	return 0;
+}
+
+static int iwg15_backlight_resume(struct platform_device *pdev)
+{
+	struct imx6_iwg15_backlight *iwg15_backlight = dev_get_drvdata(&pdev->dev);
+
+	backlight_ctrl(iwg15_backlight, 1);
+	power_ctrl(iwg15_backlight, 1);
+
+	return 0;
+}
+#endif
+
+/* 
+ * iwg15_backlight_probe - Probe method for the LVDS contolling GPIOs.
+ * @np: pointer to device tree node
+ *
+ * This function probes the RainboW G15 control GPIOs in the device tree. It request GPIOs
+ * as outptu. It returns 0, if the driver registered
+ * or a negative value if there is an error.
+ */
+static int iwg15_backlight_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct imx6_iwg15_backlight *imx6_iwg15_backlight;
+	int ret=0;
+
+	imx6_iwg15_backlight = devm_kzalloc(&pdev->dev, sizeof(*imx6_iwg15_backlight), GFP_KERNEL);
+	if (!imx6_iwg15_backlight)
+		return -ENOMEM;
+
+	/* Fetch GPIOs */
+	imx6_iwg15_backlight->backlght_on_gpio = of_get_named_gpio(np, "backlgt-gpios", 0);
+	if (gpio_is_valid(imx6_iwg15_backlight->backlght_on_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+				imx6_iwg15_backlight->backlght_on_gpio,
+				GPIOF_OUT_INIT_HIGH,
+				"lvds bklight");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get backlight gpio\n");
+			goto err;
+		}
+	}
+
+	imx6_iwg15_backlight->power_on_gpio = of_get_named_gpio(np, "poweron-gpios", 0);
+	if (gpio_is_valid(imx6_iwg15_backlight->power_on_gpio)) {
+		ret = devm_gpio_request_one(&pdev->dev,
+				imx6_iwg15_backlight->power_on_gpio,
+				GPIOF_OUT_INIT_HIGH,
+				"lvds power enable");
+		if (ret) {
+			dev_err(&pdev->dev, "unable to get power-on gpio\n");
+			goto err;
+		}
+	}
+
+	platform_set_drvdata(pdev, imx6_iwg15_backlight);
+
+	/* Create the device attr */
+	ret = device_create_file(&pdev->dev, &dev_attr_bklight_enable);
+	if (ret < 0)
+		dev_warn(&pdev->dev,
+				"cound not create sys node for backlight state\n");
+
+	ret = device_create_file(&pdev->dev, &dev_attr_pwr_enable);
+	if (ret < 0)
+		dev_warn(&pdev->dev,
+				"cound not create sys node for power state\n");
+
+err:
+	return ret;
+}
+
+static int iwg15_backlight_remove(struct platform_device *pdev)
+{
+	/* Platform not registerd return silently */
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id iwg15_backlight_match[] = {
+	{.compatible = "iwave,iwg15-backlight"},
+	{}
+};
+MODULE_DEVICE_TABLE(of, iwg15_backlight_match);
+#else
+#define iwg15_backlight_match NULL
+#endif
+
+static struct platform_driver iwg15_backlight_driver = {
+	.driver = {
+		.name   = "iwg15-backlight",
+		.owner  = THIS_MODULE,
+		.of_match_table = of_match_ptr(iwg15_backlight_match),
+	},
+	.probe          = iwg15_backlight_probe,
+	.remove         = iwg15_backlight_remove,
+        .suspend 	= iwg15_backlight_suspend,
+        .resume 	= iwg15_backlight_resume,
+};
+
+static int __init iwg15_backlight_init(void)
+{
+	return platform_driver_register(&iwg15_backlight_driver);
+}
+module_init(iwg15_backlight_init);
+
+static void __exit iwg15_backlight_exit(void)
+{
+	platform_driver_unregister(&iwg15_backlight_driver);
+}
+module_exit(iwg15_backlight_exit);
+
+MODULE_AUTHOR("iWave Systems Technologies Pvt.Ltd");
+MODULE_DESCRIPTION("iWave LVDS power and backlight Driver");
+MODULE_VERSION("0.1");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/video/fbdev/mxc/mxc_lcdif.c b/drivers/video/fbdev/mxc/mxc_lcdif.c
index 59d429c82017..1fe49a57666a 100644
--- a/drivers/video/fbdev/mxc/mxc_lcdif.c
+++ b/drivers/video/fbdev/mxc/mxc_lcdif.c
@@ -36,6 +36,15 @@ struct mxc_lcdif_data {
 #define DISPDRV_LCD	"lcd"
 
 static struct fb_videomode lcdif_modedb[] = {
+#ifdef CONFIG_IWG15
+        /* IWG15M-SM: LCD: Parameters for the WQVGA LCD used */
+        {
+        /* 480x272 @ 57 Hz , pixel clk @ 27MHz */
+        "WQVGA", 60, 480, 272, 30030, 2, 2, 1, 2, 41, 10,
+        FB_SYNC_CLK_LAT_FALL,
+        FB_VMODE_NONINTERLACED,
+        0,},
+#endif
 	{
 	/* 800x480 @ 57 Hz , pixel clk @ 27MHz */
 	"CLAA-WVGA", 57, 800, 480, 37037, 40, 60, 10, 10, 20, 10,
diff --git a/drivers/watchdog/imx2_wdt.c b/drivers/watchdog/imx2_wdt.c
index 805df6b33625..2520095b3443 100644
--- a/drivers/watchdog/imx2_wdt.c
+++ b/drivers/watchdog/imx2_wdt.c
@@ -67,6 +67,11 @@
 #define WDOG_SEC_TO_COUNT(s)	((s * 2 - 1) << 8)
 #define WDOG_SEC_TO_PRECOUNT(s)	(s * 2)		/* set WDOG pre timeout count*/
 
+#ifdef CONFIG_IWG15
+/* IWG15S: WDOG: Fixed for watchdog Application reset issue in PICO */
+extern void pfuze_core_val (void);
+#endif
+
 struct imx2_wdt_device {
 	struct clk *clk;
 	struct regmap *regmap;
@@ -198,6 +203,13 @@ static int imx2_wdt_start(struct watchdog_device *wdog)
 	} else
 		imx2_wdt_setup(wdog);
 
+#ifdef CONFIG_IWG15
+	/* IWG15S: WDOG: Fixed for watchdog Application reset issue */
+	if (of_machine_is_compatible("iw,qd_iwg15m_sm") ||
+			of_machine_is_compatible("iw,dls_iwg15m_sm"))
+		pfuze_core_val();
+#endif
+
 	return imx2_wdt_ping(wdog);
 }
 
diff --git a/include/linux/regulator/pfuze100.h b/include/linux/regulator/pfuze100.h
index 70c6c66c5bcf..9c0b9c43b2d0 100644
--- a/include/linux/regulator/pfuze100.h
+++ b/include/linux/regulator/pfuze100.h
@@ -24,6 +24,21 @@
 #define PFUZE100_SW3A		3
 #define PFUZE100_SW3B		4
 #define PFUZE100_SW4		5
+#if defined( CONFIG_IWG15M_Q7) || defined( CONFIG_IWG15M_SM)
+#define PFUZE100_VSNVS		6
+#define PFUZE100_VREFDDR	7
+#define PFUZE100_VGEN4		8
+#define PFUZE100_VGEN5		9
+#define PFUZE100_MAX_REGULATOR	10
+#elif defined (CONFIG_IWG15S_PICO)
+#define PFUZE100_VSNVS          6
+#define PFUZE100_VREFDDR        7
+#define PFUZE100_VGEN2          8
+#define PFUZE100_VGEN3          9
+#define PFUZE100_VGEN4          10
+#define PFUZE100_VGEN5          11
+#define PFUZE100_MAX_REGULATOR 	12
+#else
 #define PFUZE100_SWBST		6
 #define PFUZE100_VSNVS		7
 #define PFUZE100_VREFDDR	8
@@ -34,6 +49,7 @@
 #define PFUZE100_VGEN5		13
 #define PFUZE100_VGEN6		14
 #define PFUZE100_MAX_REGULATOR	15
+#endif
 
 #define PFUZE200_SW1AB		0
 #define PFUZE200_SW2		1
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index 3a29c0ac5d8a..db9683e0e0c1 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -435,7 +435,12 @@ static const struct snd_kcontrol_new sgtl5000_snd_controls[] = {
 
 	SOC_DOUBLE_TLV("Headphone Playback Volume",
 			SGTL5000_CHIP_ANA_HP_CTRL,
+#ifdef CONFIG_IWG15
+			/* IWG15: AUDIO: Increasing Headphone Playback Volume */
+			1, 9,
+#else
 			0, 8,
+#endif
 			0x7f, 1,
 			headphone_volume),
 	SOC_SINGLE("Headphone Playback ZC Switch", SGTL5000_CHIP_ANA_CTRL,
