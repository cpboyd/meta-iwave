diff --git a/arch/arm/include/asm/arch-mx6/mx6-ddr.h b/arch/arm/include/asm/arch-mx6/mx6-ddr.h
index 19d2f1d9c5..e103e134f5 100644
--- a/arch/arm/include/asm/arch-mx6/mx6-ddr.h
+++ b/arch/arm/include/asm/arch-mx6/mx6-ddr.h
@@ -6,6 +6,8 @@
 #ifndef __ASM_ARCH_MX6_DDR_H__
 #define __ASM_ARCH_MX6_DDR_H__
 
+#ifndef IWCONFIG_MX6_IWG15
+/* IWG15: DDR: DDR Registers are not using DCD Settings */
 #ifndef CONFIG_SPL_BUILD
 #ifdef CONFIG_MX6Q
 #include "mx6q-ddr.h"
@@ -471,6 +473,7 @@ void mx6_dram_cfg(const struct mx6_ddr_sysinfo *,
 		  const void *);
 
 #endif /* CONFIG_SPL_BUILD */
+#endif /* IWCONFIG_MX6_IWG15 */
 
 #define MX6_MMDC_P0_MDCTL	0x021b0000
 #define MX6_MMDC_P0_MDPDC	0x021b0004
diff --git a/arch/arm/include/asm/arch-mx6/mx6_plugin.S b/arch/arm/include/asm/arch-mx6/mx6_plugin.S
index 02d855fbc3..c09cb1c717 100644
--- a/arch/arm/include/asm/arch-mx6/mx6_plugin.S
+++ b/arch/arm/include/asm/arch-mx6/mx6_plugin.S
@@ -64,6 +64,26 @@ plugin_start:
 before_calling_rom___pu_irom_hwcnfg_setup:
 	ldr r3, =ROM_VERSION_OFFSET
 	ldr r4, [r3]
+#ifdef IWCONFIG_MX6_IWG15
+	/* IWG15: SingleBinary: Checking Processor Type */
+	ldr r5, =ANATOP_BASE_ADDR
+	ldr r6, [r5,#0x260]
+	ldr r3,=0xff0000
+	and r6,r6,r3
+	cmp r6,#0x630000
+	beq quad
+
+	ldr r3, =ROM_VERSION_TO12
+	cmp r4, r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DL_TO12
+	ldrlt r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+	b common
+quad:
+	ldr r3, =ROM_VERSION_TO15
+	cmp r4, r3
+	ldrge r3, =ROM_API_TABLE_BASE_ADDR_MX6DQ_TO15
+	ldrlt r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
+#else /* IWCONFIG_MX6_IWG15 */
 #if defined(CONFIG_MX6S) || defined(CONFIG_MX6DL)
 	ldr r3, =ROM_VERSION_TO12
 	cmp r4, r3
@@ -77,6 +97,8 @@ before_calling_rom___pu_irom_hwcnfg_setup:
 #else
 	ldr r3, =ROM_API_TABLE_BASE_ADDR_LEGACY
 #endif
+#endif /* IWCONFIG_MX6_IWG15 */
+common:
 	ldr r4, [r3, #ROM_API_HWCNFG_SETUP_OFFSET]
 	blx r4
 after_calling_rom___pu_irom_hwcnfg_setup:
diff --git a/arch/arm/mach-imx/mx6/Kconfig b/arch/arm/mach-imx/mx6/Kconfig
index d5a5a7a38b..3edf905325 100644
--- a/arch/arm/mach-imx/mx6/Kconfig
+++ b/arch/arm/mach-imx/mx6/Kconfig
@@ -129,6 +129,15 @@ config TARGET_MX6SABRESD
     select BOARD_EARLY_INIT_F
     select NXP_BOARD_REVISION
 
+config TARGET_MX6_IWG15M_SM
+	bool "mx6_iwg15m_sm"
+	select BOARD_LATE_INIT
+	select MX6QDL
+	select DM
+	select DM_THERMAL
+	select BOARD_EARLY_INIT_F
+	select NXP_BOARD_REVISION
+
 config TARGET_MX6QDLARM2
     bool
     select BOARD_LATE_INIT
@@ -649,6 +658,7 @@ source "board/freescale/mx6ul_14x14_ddr3_arm2/Kconfig"
 source "board/freescale/mx6ul_14x14_lpddr2_arm2/Kconfig"
 source "board/freescale/mx6ullevk/Kconfig"
 source "board/freescale/mx6ull_ddr3_arm2/Kconfig"
+source "board/freescale/mx6_iwg15m_sm/Kconfig"
 source "board/grinn/liteboard/Kconfig"
 source "board/phytec/pcm058/Kconfig"
 source "board/phytec/pfla02/Kconfig"
diff --git a/board/freescale/mx6_iwg15m_sm/Kconfig b/board/freescale/mx6_iwg15m_sm/Kconfig
new file mode 100644
index 0000000000..98721e2fae
--- /dev/null
+++ b/board/freescale/mx6_iwg15m_sm/Kconfig
@@ -0,0 +1,18 @@
+if TARGET_MX6_IWG15M_SM	
+
+config SYS_BOARD
+	default "mx6_iwg15m_sm"
+
+config SYS_VENDOR
+	default "freescale"
+
+config SYS_SOC
+	default "mx6"
+
+config SYS_CONFIG_NAME
+	default "mx6_iwg15m_sm"
+
+config SYS_TEXT_BASE
+	default 0x17800000
+
+endif
diff --git a/board/freescale/mx6_iwg15m_sm/MAINTAINERS b/board/freescale/mx6_iwg15m_sm/MAINTAINERS
new file mode 100644
index 0000000000..cb786c4124
--- /dev/null
+++ b/board/freescale/mx6_iwg15m_sm/MAINTAINERS
@@ -0,0 +1,8 @@
+MX6_IWG15M_SM BOARD
+M:	iWavesystems <support.ip@iwavesystems.com>
+S:	Maintained
+F:	board/freescale/mx6_iwg15m_sm/
+F:	include/configs/mx6_iwg15m_sm.h
+F:	configs/mx6_iwg15m_sm_defconfig
+F:	configs/mx6_iwg15m_sm_dls_mfg_defconfig
+F:	configs/mx6_iwg15m_sm_qd_mfg_defconfig
diff --git a/board/freescale/mx6_iwg15m_sm/Makefile b/board/freescale/mx6_iwg15m_sm/Makefile
new file mode 100644
index 0000000000..731059ccde
--- /dev/null
+++ b/board/freescale/mx6_iwg15m_sm/Makefile
@@ -0,0 +1,7 @@
+#
+# Copyright (c) 2017 iWave Systems Technologies Pvt. Ltd.
+#
+# SPDX-License-Identifier:	GPL-2.0+
+#
+
+obj-y  := mx6_iwg15m_sm.o
diff --git a/board/freescale/mx6_iwg15m_sm/mx6_iwg15m.cfg b/board/freescale/mx6_iwg15m_sm/mx6_iwg15m.cfg
new file mode 100644
index 0000000000..484b8e3c2a
--- /dev/null
+++ b/board/freescale/mx6_iwg15m_sm/mx6_iwg15m.cfg
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2017 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+/*
+ * @file mx6_iwg15m.cfg 
+ *
+ * @brief Plugin Mode Binary invoking 
+ *
+ * @ingroup Plugin
+ */
+
+#define __ASSEMBLY__
+#include <config.h>
+
+/* image version */
+
+IMAGE_VERSION 2
+
+/*
+ * Boot Device : one of spi, sd, sata
+ * the board has no nand and eimnor
+ * spinor: flash_offset: 0x0400
+ * sata:   flash_offset: 0x0400
+ * sd/mmc: flash_offset: 0x0400
+ */
+
+/* the same flash_offset as sd */
+BOOT_FROM	sd
+
+#ifdef CONFIG_USE_IMXIMG_PLUGIN
+/*PLUGIN    plugin-binary-file    IRAM_FREE_START_ADDR*/
+PLUGIN	board/freescale/mx6_iwg15m_sm/plugin.bin 0x00907000
+#else
+
+#ifdef CONFIG_SECURE_BOOT
+CSF CONFIG_CSF_SIZE
+#endif
+
+/*
+ * Device Configuration Data (DCD)
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ *	Addr-type register length (1,2 or 4 bytes)
+ *	Address   absolute address of the register
+ *	value     value to be stored in the register
+ */
+DATA 4 0x020e0798 0x000C0000
+DATA 4 0x020e0758 0x00000000
+DATA 4 0x020e0588 0x00000030
+DATA 4 0x020e0594 0x00000030
+DATA 4 0x020e056c 0x00000030
+DATA 4 0x020e0578 0x00000030
+DATA 4 0x020e074c 0x00000030
+DATA 4 0x020e057c 0x00000030
+DATA 4 0x020e058c 0x00000000
+DATA 4 0x020e059c 0x00000030
+DATA 4 0x020e05a0 0x00000030
+DATA 4 0x020e078c 0x00000030
+DATA 4 0x020e0750 0x00020000
+DATA 4 0x020e05a8 0x00000030
+DATA 4 0x020e05b0 0x00000030
+DATA 4 0x020e0524 0x00000030
+DATA 4 0x020e051c 0x00000030
+DATA 4 0x020e0518 0x00000030
+DATA 4 0x020e050c 0x00000030
+DATA 4 0x020e05b8 0x00000030
+DATA 4 0x020e05c0 0x00000030
+DATA 4 0x020e0774 0x00020000
+DATA 4 0x020e0784 0x00000030
+DATA 4 0x020e0788 0x00000030
+DATA 4 0x020e0794 0x00000030
+DATA 4 0x020e079c 0x00000030
+DATA 4 0x020e07a0 0x00000030
+DATA 4 0x020e07a4 0x00000030
+DATA 4 0x020e07a8 0x00000030
+DATA 4 0x020e0748 0x00000030
+DATA 4 0x020e05ac 0x00000030
+DATA 4 0x020e05b4 0x00000030
+DATA 4 0x020e0528 0x00000030
+DATA 4 0x020e0520 0x00000030
+DATA 4 0x020e0514 0x00000030
+DATA 4 0x020e0510 0x00000030
+DATA 4 0x020e05bc 0x00000030
+DATA 4 0x020e05c4 0x00000030
+DATA 4 0x021b0800 0xa1390003
+DATA 4 0x021b080c 0x001F001F
+DATA 4 0x021b0810 0x001F001F
+DATA 4 0x021b480c 0x001F001F
+DATA 4 0x021b4810 0x001F001F
+DATA 4 0x021b083c 0x43270338
+DATA 4 0x021b0840 0x03200314
+DATA 4 0x021b483c 0x431A032F
+DATA 4 0x021b4840 0x03200263
+DATA 4 0x021b0848 0x4B434748
+DATA 4 0x021b4848 0x4445404C
+DATA 4 0x021b0850 0x38444542
+DATA 4 0x021b4850 0x4935493A
+DATA 4 0x021b081c 0x33333333
+DATA 4 0x021b0820 0x33333333
+DATA 4 0x021b0824 0x33333333
+DATA 4 0x021b0828 0x33333333
+DATA 4 0x021b481c 0x33333333
+DATA 4 0x021b4820 0x33333333
+DATA 4 0x021b4824 0x33333333
+DATA 4 0x021b4828 0x33333333
+DATA 4 0x021b08b8 0x00000800
+DATA 4 0x021b48b8 0x00000800
+DATA 4 0x021b0004 0x00020036
+DATA 4 0x021b0008 0x09444040
+DATA 4 0x021b000c 0x555A7975
+DATA 4 0x021b0010 0xFF538F64
+DATA 4 0x021b0014 0x01FF00DB
+DATA 4 0x021b0018 0x00001740
+DATA 4 0x021b001c 0x00008000
+DATA 4 0x021b002c 0x000026d2
+DATA 4 0x021b0030 0x005A1023
+DATA 4 0x021b0040 0x00000027
+DATA 4 0x021b0000 0x831A0000
+DATA 4 0x021b001c 0x04088032
+DATA 4 0x021b001c 0x00008033
+DATA 4 0x021b001c 0x00048031
+DATA 4 0x021b001c 0x09408030
+DATA 4 0x021b001c 0x04008040
+DATA 4 0x021b0020 0x00005800
+DATA 4 0x021b0818 0x00011117
+DATA 4 0x021b4818 0x00011117
+DATA 4 0x021b0004 0x00025576
+DATA 4 0x021b0404 0x00011006
+DATA 4 0x021b001c 0x00000000
+
+/* set the default clock gate to save power */
+DATA 4 0x020c4068 0x00C03F3F
+DATA 4 0x020c406c 0x0030FC03
+DATA 4 0x020c4070 0x0FFFC000
+DATA 4 0x020c4074 0x3FF00000
+DATA 4 0x020c4078 0x00FFF300
+DATA 4 0x020c407c 0x0F0000F3
+DATA 4 0x020c4080 0x000003FF
+
+/* enable AXI cache for VDOA/VPU/IPU */
+DATA 4 0x020e0010 0xF00000CF
+/* set IPU AXI-id0 Qos=0xf(bypass) AXI-id1 Qos=0x7 */
+DATA 4 0x020e0018 0x007F007F
+DATA 4 0x020e001c 0x007F007F
+
+/*
+ * Setup CCM_CCOSR register as follows:
+ *
+ * cko1_en  = 1	   --> CKO1 enabled
+ * cko1_div = 111  --> divide by 8
+ * cko1_sel = 1011 --> ahb_clk_root
+ *
+ * This sets CKO1 at ahb_clk_root/8 = 132/8 = 16.5 MHz
+ */
+DATA 4 0x020c4060 0x000000fb
+#endif
diff --git a/board/freescale/mx6_iwg15m_sm/mx6_iwg15m_sm.c b/board/freescale/mx6_iwg15m_sm/mx6_iwg15m_sm.c
new file mode 100644
index 0000000000..edef529ed3
--- /dev/null
+++ b/board/freescale/mx6_iwg15m_sm/mx6_iwg15m_sm.c
@@ -0,0 +1,755 @@
+/*
+ * Copyright (c) 2017 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 3
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <asm/arch/clock.h>
+#include <asm/arch/imx-regs.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/mach-imx/spi.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/mxc_i2c.h>
+#include <asm/mach-imx/iomux-v3.h>
+#include <asm/mach-imx/boot_mode.h>
+#include <asm/mach-imx/video.h>
+#include <mmc.h>
+#include <fsl_esdhc.h>
+#include <micrel.h>
+#include <miiphy.h>
+#include <netdev.h>
+#include <asm/arch/mxc_hdmi.h>
+#include <asm/arch/crm_regs.h>
+#include <asm/io.h>
+#include <asm/arch/sys_proto.h>
+#include <i2c.h>
+#include <input.h>
+#include <power/pmic.h>
+#include <power/pfuze100_pmic.h>
+#include "../common/pfuze.h"
+#include <usb.h>
+#include <usb/ehci-ci.h>
+#include <asm/arch/mx6-ddr.h>
+#ifdef CONFIG_SATA
+#include <asm/mach-imx/sata.h>
+#endif
+#ifdef CONFIG_FSL_FASTBOOT
+#include <fsl_fastboot.h>
+#endif /*CONFIG_FSL_FASTBOOT*/
+#include "mx6_iwg15m_sm.h"
+
+DECLARE_GLOBAL_DATA_PTR;
+
+#define UART_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define USDHC_PAD_CTRL (PAD_CTL_PUS_47K_UP |			\
+	PAD_CTL_SPEED_LOW | PAD_CTL_DSE_80ohm |			\
+	PAD_CTL_SRE_FAST  | PAD_CTL_HYS)
+
+#define ENET_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS)
+
+#define SPI_PAD_CTRL (PAD_CTL_HYS | PAD_CTL_SPEED_MED | \
+	PAD_CTL_DSE_40ohm | PAD_CTL_SRE_FAST)
+
+#define I2C_PAD_CTRL  (PAD_CTL_PUS_100K_UP |			\
+	PAD_CTL_SPEED_MED | PAD_CTL_DSE_40ohm | PAD_CTL_HYS |	\
+	PAD_CTL_ODE | PAD_CTL_SRE_FAST)
+
+#define I2C_PMIC	0
+#define I2C_PAD 	MUX_PAD_CTRL(I2C_PAD_CTRL)
+
+#define BACKLIGHT_EN	IMX_GPIO_NR(1, 17)
+#define LCD_PWR_EN	IMX_GPIO_NR(4, 13)
+#define LCD_RESET	IMX_GPIO_NR(7, 11)
+#define HDMI_CEC_EN	IMX_GPIO_NR(1, 21)
+#define COM_RESET_GPIO	IMX_GPIO_NR(1, 11)
+
+#define is_mx6dlsolo()	(is_mx6dl() || is_mx6solo())
+
+int dram_init(void)
+{
+	if (is_mx6solo())
+		gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE_512MB);
+	else
+		gd->ram_size = get_ram_size((void *)PHYS_SDRAM, PHYS_SDRAM_SIZE);
+
+	return 0;
+}
+
+static iomux_v3_cfg_t const uart2_pads[] = {
+	IOMUX_PADS(PAD_EIM_D27__UART2_RX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D26__UART2_TX_DATA | MUX_PAD_CTRL(UART_PAD_CTRL)),
+};
+
+static iomux_v3_cfg_t const enet_pads[] = {
+	IOMUX_PADS(PAD_ENET_MDIO__ENET_MDIO	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_MDC__ENET_MDC	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TXC__RGMII_TXC	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD0__RGMII_TD0	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD1__RGMII_TD1	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD2__RGMII_TD2	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TD3__RGMII_TD3	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_TX_CTL__RGMII_TX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_REF_CLK__ENET_TX_CLK | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RXC__RGMII_RXC	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD0__RGMII_RD0	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD1__RGMII_RD1	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD2__RGMII_RD2	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RD3__RGMII_RD3	| MUX_PAD_CTRL(ENET_PAD_CTRL)),
+	IOMUX_PADS(PAD_RGMII_RX_CTL__RGMII_RX_CTL | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+};
+
+static void setup_iomux_enet(void)
+{
+	SETUP_IOMUX_PADS(enet_pads);
+}
+
+static iomux_v3_cfg_t const usdhc3_pads[] = {
+	IOMUX_PADS(PAD_SD3_DAT0__SD3_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT1__SD3_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT2__SD3_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT3__SD3_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_CLK__SD3_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_CMD__SD3_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D25__GPIO3_IO25 | MUX_PAD_CTRL(NO_PAD_CTRL)), /* CD */
+};
+
+static iomux_v3_cfg_t const usdhc4_pads[] = {
+	IOMUX_PADS(PAD_SD4_CLK__SD4_CLK   | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_CMD__SD4_CMD   | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT0__SD4_DATA0 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT1__SD4_DATA1 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT2__SD4_DATA2 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT3__SD4_DATA3 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT4__SD4_DATA4 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT5__SD4_DATA5 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT6__SD4_DATA6 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD4_DAT7__SD4_DATA7 | MUX_PAD_CTRL(USDHC_PAD_CTRL)),
+};
+
+#ifdef CONFIG_MXC_SPI
+static iomux_v3_cfg_t const ecspi1_pads[] = {
+	IOMUX_PADS(PAD_EIM_D16__ECSPI1_SCLK | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D17__ECSPI1_MISO | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_D18__ECSPI1_MOSI | MUX_PAD_CTRL(SPI_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_EB2__GPIO2_IO30  | MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+static void setup_spi(void)
+{
+	SETUP_IOMUX_PADS(ecspi1_pads);
+}
+
+int board_spi_cs_gpio(unsigned bus, unsigned cs)
+{
+	return (bus == 0 && cs == 0) ? (IMX_GPIO_NR(2, 30)) : -1;
+}
+#endif
+
+static iomux_v3_cfg_t const bl_pads[] = {
+	IOMUX_PADS(PAD_SD1_DAT1__GPIO1_IO17 | MUX_PAD_CTRL(ENET_PAD_CTRL)),
+};
+
+static void setup_iomux_backlight_off(void)
+{
+	/* Setup backlight */
+	SETUP_IOMUX_PADS(bl_pads);
+	/* Turn off backlight until display is ready */
+	gpio_request(BACKLIGHT_EN, "Display Backlight Enable");
+	gpio_direction_output(BACKLIGHT_EN, 1);
+}
+
+#ifdef CONFIG_SYS_I2C
+struct i2c_pads_info i2c_pad_dq_info0 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_EIM_D21__I2C1_SCL | I2C_PAD,
+		.gpio_mode = MX6Q_PAD_EIM_D21__GPIO3_IO21 | I2C_PAD,
+		.gp = IMX_GPIO_NR(3, 21)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_EIM_D28__I2C1_SDA | I2C_PAD,
+		.gpio_mode = MX6Q_PAD_EIM_D28__GPIO3_IO28 | I2C_PAD,
+		.gp = IMX_GPIO_NR(3, 28)
+	},
+};
+
+struct i2c_pads_info i2c_pad_dl_info0 = {
+	.scl = {
+		.i2c_mode = MX6DL_PAD_EIM_D21__I2C1_SCL | I2C_PAD,
+		.gpio_mode = MX6DL_PAD_EIM_D21__GPIO3_IO21 | I2C_PAD,
+		.gp = IMX_GPIO_NR(3, 21)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_EIM_D28__I2C1_SDA | I2C_PAD,
+		.gpio_mode = MX6DL_PAD_EIM_D28__GPIO3_IO28 | I2C_PAD,
+		.gp = IMX_GPIO_NR(3, 28)
+	},
+};
+
+struct i2c_pads_info i2c_pad_dq_info2 = {
+	.scl = {
+		.i2c_mode = MX6Q_PAD_GPIO_3__I2C3_SCL | I2C_PAD,
+		.gpio_mode = MX6Q_PAD_GPIO_3__GPIO1_IO03 | I2C_PAD,
+		.gp = IMX_GPIO_NR(1, 3)
+	},
+	.sda = {
+		.i2c_mode = MX6Q_PAD_GPIO_6__I2C3_SDA | I2C_PAD,
+		.gpio_mode = MX6Q_PAD_GPIO_6__GPIO1_IO06 | I2C_PAD,
+		.gp = IMX_GPIO_NR(1, 6)
+	},
+};
+
+struct i2c_pads_info i2c_pad_dl_info2 = {
+	.scl = {
+		.i2c_mode = MX6DL_PAD_GPIO_3__I2C3_SCL | I2C_PAD,
+		.gpio_mode = MX6DL_PAD_GPIO_3__GPIO1_IO03 | I2C_PAD,
+		.gp = IMX_GPIO_NR(1, 3)
+	},
+	.sda = {
+		.i2c_mode = MX6DL_PAD_GPIO_6__I2C3_SDA | I2C_PAD,
+		.gpio_mode = MX6DL_PAD_GPIO_6__GPIO1_IO06 | I2C_PAD,
+		.gp = IMX_GPIO_NR(1, 6)
+	},
+};
+#endif
+
+static void setup_iomux_uart(void)
+{
+	SETUP_IOMUX_PADS(uart2_pads);
+}
+
+#ifdef CONFIG_FSL_ESDHC
+struct fsl_esdhc_cfg usdhc_cfg[2] = {
+	{USDHC3_BASE_ADDR},
+	{USDHC4_BASE_ADDR},
+};
+
+#define USDHC3_CD_GPIO	IMX_GPIO_NR(3, 25)
+
+int board_mmc_get_env_dev(int devno)
+{
+	return (devno > 1) ? devno - 1 : devno;
+}
+
+int mmc_map_to_kernel_blk(int devno)
+{
+	return devno + 2;
+}
+
+int board_mmc_getcd(struct mmc *mmc)
+{
+	struct fsl_esdhc_cfg *cfg = (struct fsl_esdhc_cfg *)mmc->priv;
+	int ret = 0;
+
+	switch (cfg->esdhc_base) {
+	case USDHC3_BASE_ADDR:
+		ret = !gpio_get_value(USDHC3_CD_GPIO);
+		break;
+	case USDHC4_BASE_ADDR:
+		ret = 1; /* eMMC/uSDHC4 is always present */
+		break;
+	}
+
+	return ret;
+}
+
+int board_mmc_init(bd_t *bis)
+{
+	int ret;
+	int i;
+
+	/*
+	 * According to the board_mmc_init() the following map is done:
+	 * (U-boot device node)    (Physical Port)
+	 * mmc0                    SD3
+	 * mmc1                    eMMC
+	 */
+	for (i = 0; i < CONFIG_SYS_FSL_USDHC_NUM; i++) {
+		switch (i) {
+		case 0:
+			SETUP_IOMUX_PADS(usdhc3_pads);
+			gpio_direction_input(USDHC3_CD_GPIO);
+			usdhc_cfg[0].sdhc_clk = mxc_get_clock(MXC_ESDHC3_CLK);
+			break;
+		case 1:
+			SETUP_IOMUX_PADS(usdhc4_pads);
+			usdhc_cfg[1].sdhc_clk = mxc_get_clock(MXC_ESDHC4_CLK);
+			break;
+		default:
+			printf("Warning: you configured more USDHC controllers"
+				"(%d) then supported by the board (%d)\n",
+				i + 1, CONFIG_SYS_FSL_USDHC_NUM);
+			return -EINVAL;
+		}
+
+		ret = fsl_esdhc_initialize(bis, &usdhc_cfg[i]);
+		if (ret)
+			return ret;
+	}
+
+	return 0;
+}
+#endif
+
+#define MII_KSZ9031_EXT_MMD_ADD2	0x02
+int mx6_rgmii_rework(struct phy_device *phydev)
+{
+	if (strcasecmp(phydev->drv->name, "Micrel ksz9031") == 0 &&
+			((phydev->drv->uid & phydev->drv->mask) ==
+			(phydev->phy_id & phydev->drv->mask))) {
+
+		printf("Configuring PHY skew timing for %s\n",
+			phydev->drv->name);
+
+		/* IWG15M: ETHERNET: Final Skew settings for Rev4.0 PHY9031 */
+		/* min rx/tx control */
+		if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+				MII_KSZ9031_EXT_RGMII_CTRL_SIG_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW,0x0080) < 0)
+			return -1;
+
+		/* min rx data delay */
+		if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+				MII_KSZ9031_EXT_RGMII_RX_DATA_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW,0x7787) < 0)
+			return -1;
+		/* min tx data delay */
+		if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+				MII_KSZ9031_EXT_RGMII_TX_DATA_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW, 0x0000 ) < 0)
+			return -1;
+		/* max rx/tx clock delay */
+		if (ksz9031_phy_extended_write(phydev,MII_KSZ9031_EXT_MMD_ADD2,
+				MII_KSZ9031_EXT_RGMII_CLOCK_SKEW, MII_KSZ9031_MOD_DATA_POST_INC_RW,0x03ff) < 0)
+			return -1;
+
+		}
+
+	return 0;
+}
+
+int board_phy_config(struct phy_device *phydev)
+{
+	mx6_rgmii_rework(phydev);
+
+	if (phydev->drv->config)
+		phydev->drv->config(phydev);
+
+	return 0;
+}
+
+/* Check the u-boot LDO regultor mode set in u-boot 
+ * 0 - ldo active mode
+ * 1 - ldo bypass mode
+ */
+int check_uboot_ldobypass(void)
+{
+	char *ldo_check = NULL;
+	ldo_check = env_get("uboot_ldo_bypass");
+	ulong uboot_ldobypass = 0;
+	if (NULL == ldo_check) {
+		puts("env uboot_ldo_bypass not found!\n");
+		return 0;
+	}
+	uboot_ldobypass = simple_strtoul(ldo_check, NULL, 16);
+	if (uboot_ldobypass)
+		return 1;
+	return 0;
+}
+
+char *get_fdt_dev(void)
+{
+	char *fdt_dev = env_get("fdt_dev");
+	if (fdt_dev == NULL) {
+		return (is_mx6dq()) ? "imx6qd-iwg15m-sm" : "imx6dls-iwg15m-sm";
+	}
+	return fdt_dev;
+}
+
+int dynamic_fdt_file_selection(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
+{
+	const int MAX_STR_LEN = 32;
+	char filename[MAX_STR_LEN];
+	char *mode = (check_1_2G() || !check_uboot_ldobypass()) ? "active" : "bypass";
+
+	snprintf(filename, MAX_STR_LEN, "%s_ldo%s.dtb", get_fdt_dev(), mode);
+	printf ("using %s\n", filename);
+	env_set("fdt_file", filename);
+	return 0;
+}
+
+U_BOOT_CMD(
+	dynamicfdt, 1, 0, dynamic_fdt_file_selection,
+	"Loading Device tree by checking Processor",
+	""
+);
+
+static void unused_gpio_setup(void)
+{
+	int i;
+	SETUP_IOMUX_PADS(unused_gpio_pads_pmic);
+	for (i=0;i<ARRAY_SIZE(unused_gpio_pads_pmic);i++)
+	{
+		gpio_request(unused_gpio_pads_pmic[i], "unusedgpio");
+		gpio_direction_input(unused_gpio_pmic[i]);
+	}
+
+}
+
+static int get_som_revision(void)
+{
+	int i, rev=0;
+	SETUP_IOMUX_PADS(board_config_pads_som);
+	for (i=0;i<ARRAY_SIZE(board_config_pads_som);i++)
+	{
+		if (rev == 0x2)
+			continue;
+		gpio_request(board_config_pads_som[i], "SOM-Revision-GPIO");
+		gpio_direction_input(board_config_gpio_som[i]);
+		rev |= (gpio_get_value(board_config_gpio_som[i]) << i);
+	}
+
+	return rev;
+}
+
+static int get_bom_revision(int som_rev)
+{
+	int i, rev=0,bit_shift=0;
+	SETUP_IOMUX_PADS(board_config_pads_bom);
+	for (i=0;i<ARRAY_SIZE(board_config_pads_bom);i++) {
+		/* Skip one bit for 3.0 SOM */
+		if (som_rev > 2) {
+			som_rev = 0;
+			bit_shift=1;
+			continue;
+		}
+
+		gpio_request(board_config_pads_bom[i], "BOM-Revision-GPIO");
+		gpio_direction_input(board_config_gpio_bom[i]);
+		/* Skip one bit for 3.0 SOM */
+		if (bit_shift == 1)
+			rev |= (gpio_get_value(board_config_gpio_bom[i]) << (i-1));
+		else
+			rev |= (gpio_get_value(board_config_gpio_bom[i]) << i);
+	}
+
+	return rev;
+}
+
+static void print_board_info(void)
+{
+	u32 unique_id1, unique_id2;
+
+	struct ocotp_regs *ocotp = (struct ocotp_regs *)OCOTP_BASE_ADDR;
+	struct fuse_bank *bank = &ocotp->bank[0];
+	struct fuse_bank0_regs *fuse_bank0 =
+		(struct fuse_bank0_regs *)bank->fuse_regs;
+
+	unique_id1 = readl(&fuse_bank0->uid_low);
+	unique_id2 = readl(&fuse_bank0->uid_high);
+
+	printf ("\n");
+	printf ("Board Info:\n");
+	printf ("\tBSP Version     : %s\n", BSP_VERSION);
+	printf ("\tSOM Version     : iW-PREPZ-AP-01-R%x.%x\n",get_som_revision()+1,get_bom_revision(get_som_revision()+1));
+	printf ("\tCPU Unique ID   : 0x%08x%08x \n", unique_id2, unique_id1);
+	printf ("\n");
+
+}
+
+/*
+ * Do not overwrite the console
+ * Use always serial for U-Boot console
+ */
+int overwrite_console(void)
+{
+	return 1;
+}
+
+int board_eth_init(bd_t *bis)
+{
+	setup_iomux_enet();
+	return cpu_eth_init(bis);
+}
+
+int board_usb_phy_mode(int port)
+{
+	return USB_INIT_HOST;
+}
+
+int board_early_init_f(void)
+{
+	setup_iomux_uart();
+
+	/* Power OFF the LCD Backlight */
+	setup_iomux_backlight_off();
+
+	return 0;
+}
+
+int board_init(void)
+{
+	/* address of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+#ifdef CONFIG_MXC_SPI
+	setup_spi();
+#endif
+
+#ifdef CONFIG_SYS_I2C
+	if (is_mx6dq()) {
+		setup_i2c(0, CONFIG_SYS_I2C_SPEED,
+				CONFIG_SYS_I2C_SLAVE, &i2c_pad_dq_info0);
+		setup_i2c(2, CONFIG_SYS_I2C_SPEED,
+				CONFIG_SYS_I2C_SLAVE, &i2c_pad_dq_info2);
+	} else if (is_mx6dlsolo()) {
+		setup_i2c(0, CONFIG_SYS_I2C_SPEED,
+				CONFIG_SYS_I2C_SLAVE, &i2c_pad_dl_info0);
+		setup_i2c(2, CONFIG_SYS_I2C_SPEED,
+				CONFIG_SYS_I2C_SLAVE, &i2c_pad_dl_info2);
+	}
+#endif
+
+#ifdef CONFIG_SATA
+	setup_sata();
+#endif
+
+	unused_gpio_setup();
+
+	return 0;
+}
+
+#ifdef CONFIG_POWER
+int power_init_board(void)
+{
+	struct pmic *pfuze;
+	unsigned int reg;
+	int ret;
+
+	pfuze = pfuze_common_init(I2C_PMIC);
+	if (!pfuze)
+		return -ENODEV;
+
+	ret = pfuze_mode_init(pfuze, APS_PFM);
+	if (ret < 0)
+		return ret;
+
+	/* set SW1AB staby volatage 0.975V*/
+	pmic_reg_read(pfuze, PFUZE100_SW1ABSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABSTBY, reg);
+
+	/* set SW1AB/VDDARM step ramp up time from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1ABCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1ABCONF, reg);
+
+	/* set SW1C staby volatage 0.975V*/
+	pmic_reg_read(pfuze, PFUZE100_SW1CSTBY, &reg);
+	reg &= ~0x3f;
+	reg |= 0x1b;
+	pmic_reg_write(pfuze, PFUZE100_SW1CSTBY, reg);
+
+	/* set SW1C/VDDSOC step ramp up time to from 16us to 4us/25mV */
+	pmic_reg_read(pfuze, PFUZE100_SW1CCONF, &reg);
+	reg &= ~0xc0;
+	reg |= 0x40;
+	pmic_reg_write(pfuze, PFUZE100_SW1CCONF, reg);
+	
+      /* Since in IWG15M-SM, VGEN1, VGEN2, VGEN3, VGEN6 and SWBST is not used,
+	 * disabling VGEN1, VGEN2, VGEN3, VGEN 6 and SWBST
+	*/
+	/* Disabli0ng VGEN1 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN1VOL, &reg);
+	reg &= ~0x1f;
+	pmic_reg_write(pfuze, PFUZE100_VGEN1VOL, reg);
+
+	/* Disabling VGEN2 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN2VOL, &reg);
+	reg &= ~0x1f;
+	pmic_reg_write(pfuze, PFUZE100_VGEN2VOL, reg);
+
+	/* Disabling VGEN3 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN3VOL, &reg);
+	reg &= ~0x1f;
+	pmic_reg_write(pfuze, PFUZE100_VGEN3VOL, reg);
+
+	/* Disabling VGEN6 */
+	pmic_reg_read(pfuze, PFUZE100_VGEN6VOL, &reg);
+	reg &= ~0x1f;
+	pmic_reg_write(pfuze, PFUZE100_VGEN6VOL, reg);
+
+	/* Disabling SWBST */
+	pmic_reg_read(pfuze, PFUZE100_SWBSTCON1, &reg);
+	reg &= ~0x6f;
+	pmic_reg_write(pfuze, PFUZE100_SWBSTCON1, reg);
+
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_LDO_BYPASS_CHECK
+#ifdef CONFIG_POWER
+void ldo_mode_set(int ldo_bypass)
+{
+	unsigned int value;
+	int is_400M;
+	unsigned char vddarm;
+	struct pmic *p = pmic_get("PFUZE100");
+
+	if (!p) {
+		printf("No PMIC found!\n");
+		return;
+	}
+
+	/* increase VDDARM/VDDSOC to support 1.2G chip */
+	if (check_1_2G()) {
+		ldo_bypass = 0;	/* ldo_enable on 1.2G chip */
+		printf("1.2G chip, increase VDDARM_IN/VDDSOC_IN\n");
+		/* increase VDDARM to 1.425V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= 0x2d;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+		/* increase VDDSOC to 1.425V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x2d;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+	}
+	/* switch to ldo_bypass mode , boot on 800Mhz */
+	if (ldo_bypass) {
+		prep_anatop_bypass();
+		/* decrease VDDARM for 400Mhz DQ:1.1V, DL:1.275V */
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		if (is_mx6dl())
+			value |= 0x27;
+		else
+			value |= 0x20;
+
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+		/* increase VDDSOC to 1.3V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x28;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		/*
+		 * MX6Q/DQP:
+		 * VDDARM:1.15V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:0.975V@400M; VDDSOC:1.175V@400M
+		 * MX6DL:
+		 * VDDARM:1.175V@800M; VDDSOC:1.175V@800M
+		 * VDDARM:1.075V@400M; VDDSOC:1.175V@400M
+		 */
+		is_400M = set_anatop_bypass(2);
+		if (is_400M) {
+			if (is_mx6dl())
+				vddarm = 0x1f;
+			else
+				vddarm = 0x1b;
+		} else {
+			if (is_mx6dl())
+				vddarm = 0x23;
+			else
+				vddarm = 0x22;
+		}
+		pmic_reg_read(p, PFUZE100_SW1ABVOL, &value);
+		value &= ~0x3f;
+		value |= vddarm;
+		pmic_reg_write(p, PFUZE100_SW1ABVOL, value);
+
+		/* decrease VDDSOC to 1.175V */
+		pmic_reg_read(p, PFUZE100_SW1CVOL, &value);
+		value &= ~0x3f;
+		value |= 0x23;
+		pmic_reg_write(p, PFUZE100_SW1CVOL, value);
+
+		finish_anatop_bypass();
+		printf("switch to ldo_bypass mode!\n");
+	}
+}
+#endif
+#endif
+
+#ifdef CONFIG_CMD_BMODE
+static const struct boot_mode board_boot_modes[] = {
+	/* 8 bit bus width */
+	{"sd1-8", MAKE_CFGVAL(0x60, 0x40, 0x00, 0x00)},
+	{"emmc",  MAKE_CFGVAL(0x60, 0x58, 0x00, 0x00)},
+	/* 4 bit bus width */
+	{"sd3",   MAKE_CFGVAL(0x40, 0x30, 0x00, 0x00)},
+	{"sd1-4", MAKE_CFGVAL(0x40, 0x20, 0x00, 0x00)},
+	/* spi flash */
+	{"spi",   MAKE_CFGVAL(0x30, 0x00, 0x00, 0x08)},
+	/* sata */
+	{"sata",  MAKE_CFGVAL(0x20, 0x00, 0x00, 0x00)},
+	{NULL,   0},
+};
+#endif
+
+int board_late_init(void)
+{
+#ifdef CONFIG_CMD_BMODE
+	add_board_boot_modes(board_boot_modes);
+#endif
+
+   print_board_info();
+
+#ifdef CONFIG_ENV_IS_IN_MMC
+	board_late_mmc_env_init();
+#endif
+
+	return 0;
+}
+
+int checkboard(void)
+{
+	u32 cpurev;
+
+	cpurev = get_cpu_rev();
+	if (is_mx6dqp())
+		printf("Board: i.MX%sP iW-RAINBOW-G15M-SM\n",get_imx_type((cpurev & 0xFF000) >> 12));
+	else
+		printf("Board: i.MX%s iW-RAINBOW-G15M-SM\n",get_imx_type((cpurev & 0xFF000) >> 12));
+
+	printf("Boot Device: ");
+	switch (get_boot_device()) {
+	case SATA_BOOT:
+		printf("SATA\n");
+		break;
+	case SPI_NOR_BOOT:
+		printf("SPI NOR\n");
+		break;
+	case SD1_BOOT:
+		printf("STANDARD SD\n");
+		break;
+	case SD3_BOOT:
+		printf("MICRO SD\n");
+		break;
+	case MMC4_BOOT:
+		printf("MMC\n");
+		break;
+	case UNKNOWN_BOOT:
+	default:
+		printf("UNKNOWN\n");
+		break;
+	}
+
+	return 0;
+}
diff --git a/board/freescale/mx6_iwg15m_sm/mx6_iwg15m_sm.h b/board/freescale/mx6_iwg15m_sm/mx6_iwg15m_sm.h
new file mode 100644
index 0000000000..a878de367e
--- /dev/null
+++ b/board/freescale/mx6_iwg15m_sm/mx6_iwg15m_sm.h
@@ -0,0 +1,225 @@
+/*
+ * Copyright (c) 2017 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+/*
+ * @file mx6_iwg15m_sm.h
+ *
+ * @brief GPIO Defination for iMx6x SM SOMs
+ *
+ * @ingroup Main
+ */
+
+
+#include <common.h>
+#include <asm/io.h>
+#include <asm/arch/iomux.h>
+#include <asm/arch/mx6-pins.h>
+#include <asm/arch/sys_proto.h>
+#include <linux/errno.h>
+#include <asm/gpio.h>
+#include <asm/mach-imx/iomux-v3.h>
+
+#include <asm/arch/gpio.h>
+
+/* Board Configutation GPIOs */
+#define BRD_CFG0_GPIO  IMX_GPIO_NR(1, 5)
+#define BRD_CFG1_GPIO  IMX_GPIO_NR(5, 22)
+#define BRD_CFG2_GPIO  IMX_GPIO_NR(5, 23)
+#define BRD_CFG3_GPIO  IMX_GPIO_NR(5, 24)
+#define BRD_CFG4_GPIO  IMX_GPIO_NR(5, 25)
+#define BRD_CFG5_GPIO  IMX_GPIO_NR(7, 0)
+#define BRD_CFG6_GPIO  IMX_GPIO_NR(7, 1)
+
+/*  Unused GPIO pins */
+
+#define MX6_PAD_GPIO_2__GPIO1_IO02		IMX_GPIO_NR(1, 2)
+#define MX6_PAD_SD2_CLK__GPIO1_IO10		IMX_GPIO_NR(1, 10)
+#define MX6_PAD_SD2_CMD__GPIO1_IO11		IMX_GPIO_NR(1, 11)
+#define MX6_PAD_SD1_DAT0__GPIO1_IO16		IMX_GPIO_NR(1, 16)
+#define MX6_PAD_SD1_CLK__GPIO1_IO20		IMX_GPIO_NR(1, 20)
+#define MX6_PAD_SD1_DAT3__GPIO1_IO21		IMX_GPIO_NR(1, 21)
+#define MX6_PAD_ENET_RX_ER__GPIO1_IO24		IMX_GPIO_NR(1, 24)
+#define MX6_PAD_ENET_CRS_DV__GPIO1_IO25		IMX_GPIO_NR(1, 25)
+
+#define MX6_PAD_NANDF_D0__GPIO2_IO00		IMX_GPIO_NR(2, 0)
+#define MX6_PAD_NANDF_D1__GPIO2_IO01		IMX_GPIO_NR(2, 1)
+#define MX6_PAD_NANDF_D2__GPIO2_IO03		IMX_GPIO_NR(2, 2)
+#define MX6_PAD_NANDF_D3__GPIO2_IO03		IMX_GPIO_NR(2, 3)
+#define MX6_PAD_NANDF_D4__GPIO2_IO04		IMX_GPIO_NR(2, 4)
+#define MX6_PAD_NANDF_D5__GPIO2_IO05		IMX_GPIO_NR(2, 5)
+#define MX6_PAD_NANDF_D6__GPIO2_IO06		IMX_GPIO_NR(2, 6)
+#define MX6_PAD_NANDF_D7__GPIO2_IO07		IMX_GPIO_NR(2, 7)
+
+#define  MX6_PAD_KEY_COL2__GPIO4_IO10		IMX_GPIO_NR(4, 10)
+#define  MX6_PAD_KEY_ROW2__GPIO4_IO11		IMX_GPIO_NR(4, 11)
+#define  MX6_PAD_KEY_COL3__GPIO4_IO12		IMX_GPIO_NR(4, 12)
+#define  MX6_PAD_KEY_ROW3__GPIO4_IO13		IMX_GPIO_NR(4, 13)
+#define  MX6_PAD_DI0_PIN4__GPIO4_IO20		IMX_GPIO_NR(4, 20)
+
+#define  MX6_PAD_MX6_PAD_EIM_A25__GPIO5_IO02	IMX_GPIO_NR(5, 2)
+#define  MX6_PAD_CSI0_PIXCLK__GPIO5_IO18	IMX_GPIO_NR(5, 18)
+#define  MX6_PAD_CSI0_MCLK__GPIO5_IO19		IMX_GPIO_NR(5, 19)
+#define  MX6_PAD_CSI0_DATA_EN__GPIO5_IO20	IMX_GPIO_NR(5, 20)
+#define  MX6_PAD_CSI0_VSYNC__GPIO5_IO21		IMX_GPIO_NR(5, 21)
+#define  MX6_PAD_CSI0_DAT12__GPIO5_IO30		IMX_GPIO_NR(5, 30)
+#define  MX6_PAD_CSI0_DAT13__GPIO5_IO31		IMX_GPIO_NR(5, 31)
+
+#define  MX6_PAD_CSI0_DAT14__GPIO6_IO00		IMX_GPIO_NR(6, 0)
+#define  MX6_PAD_CSI0_DAT15__GPIO6_IO01		IMX_GPIO_NR(6, 1)
+#define  MX6_PAD_NANDF_CLE__GPIO6_IO07		IMX_GPIO_NR(6, 7)
+#define  MX6_PAD_NANDF_ALE__GPIO6_IO08		IMX_GPIO_NR(6, 8)
+#define  MX6_PAD_NANDF_WP_B__GPIO6_IO09		IMX_GPIO_NR(6, 9)
+#define  MX6_PAD_NANDF_RB0__GPIO6_IO10		IMX_GPIO_NR(6, 10)
+#define  MX6_PAD_NANDF_CS0__GPIO6_IO11		IMX_GPIO_NR(6, 11)
+#define  MX6_PAD_NANDF_CS1__GPIO6_IO14		IMX_GPIO_NR(6, 14)
+#define  MX6_PAD_NANDF_CS2__GPIO6_IO15		IMX_GPIO_NR(6, 15)
+#define  MX6_PAD_NANDF_CS3__GPIO6_IO16		IMX_GPIO_NR(6, 16)
+#define  MX6_PAD_EIM_BCLK__GPIO6_IO31		IMX_GPIO_NR(6, 31)
+
+#define  MX6_PAD_GPIO_16__GPIO7_IO11		IMX_GPIO_NR(7, 11)
+#define  MX6_PAD_GPIO_17__GPIO7_IO12		IMX_GPIO_NR(7, 12)
+#define  MX6_PAD_GPIO_18__GPIO7_IO13		IMX_GPIO_NR(7, 13)
+
+
+
+iomux_v3_cfg_t unused_gpio_pads_pmic[] = {
+	IOMUX_PADS(PAD_GPIO_2__GPIO1_IO02	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_CLK__GPIO1_IO10	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD2_CMD__GPIO1_IO11	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT0__GPIO1_IO16	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_CLK__GPIO1_IO20	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD1_DAT3__GPIO1_IO21	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_RX_ER__GPIO1_IO24	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_ENET_CRS_DV__GPIO1_IO25	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+
+	IOMUX_PADS(PAD_NANDF_D0__GPIO2_IO00	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_D1__GPIO2_IO01	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_D2__GPIO2_IO02	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_D3__GPIO2_IO03	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_D4__GPIO2_IO04	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_D5__GPIO2_IO05	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_D6__GPIO2_IO06	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_D7__GPIO2_IO07	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+
+	IOMUX_PADS(PAD_KEY_COL2__GPIO4_IO10	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_KEY_ROW2__GPIO4_IO11	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_KEY_COL3__GPIO4_IO12	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_KEY_ROW3__GPIO4_IO13	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_DI0_PIN4__GPIO4_IO20	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+
+	IOMUX_PADS(PAD_EIM_A25__GPIO5_IO02	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_PIXCLK__GPIO5_IO18	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_MCLK__GPIO5_IO19	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DATA_EN__GPIO5_IO20	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_VSYNC__GPIO5_IO21	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT12__GPIO5_IO30	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT13__GPIO5_IO31	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+
+	IOMUX_PADS(PAD_CSI0_DAT14__GPIO6_IO00	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT15__GPIO6_IO01	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_CLE__GPIO6_IO07	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_ALE__GPIO6_IO08	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_WP_B__GPIO6_IO09	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_RB0__GPIO6_IO10	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_CS0__GPIO6_IO11	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_CS1__GPIO6_IO14	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_CS2__GPIO6_IO15	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_NANDF_CS3__GPIO6_IO16	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_EIM_BCLK__GPIO6_IO31	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+
+	IOMUX_PADS(PAD_GPIO_16__GPIO7_IO11	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_GPIO_17__GPIO7_IO12	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_GPIO_18__GPIO7_IO13	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int unused_gpio_pmic[] = {
+	MX6_PAD_GPIO_2__GPIO1_IO02,
+	MX6_PAD_SD2_CLK__GPIO1_IO10,
+	MX6_PAD_SD2_CMD__GPIO1_IO11,
+	MX6_PAD_SD1_DAT0__GPIO1_IO16,
+	MX6_PAD_SD1_CLK__GPIO1_IO20,
+	MX6_PAD_SD1_DAT3__GPIO1_IO21,
+	MX6_PAD_ENET_RX_ER__GPIO1_IO24,
+	MX6_PAD_ENET_CRS_DV__GPIO1_IO25,
+
+	MX6_PAD_NANDF_D0__GPIO2_IO00,
+	MX6_PAD_NANDF_D1__GPIO2_IO01,
+	MX6_PAD_NANDF_D2__GPIO2_IO03,
+	MX6_PAD_NANDF_D3__GPIO2_IO03,
+	MX6_PAD_NANDF_D4__GPIO2_IO04,
+	MX6_PAD_NANDF_D5__GPIO2_IO05,
+	MX6_PAD_NANDF_D6__GPIO2_IO06,
+	MX6_PAD_NANDF_D7__GPIO2_IO07,
+
+	MX6_PAD_KEY_COL2__GPIO4_IO10,
+	MX6_PAD_KEY_ROW2__GPIO4_IO11,
+	MX6_PAD_KEY_COL3__GPIO4_IO12,
+	MX6_PAD_KEY_ROW3__GPIO4_IO13,
+	MX6_PAD_DI0_PIN4__GPIO4_IO20,
+
+	MX6_PAD_MX6_PAD_EIM_A25__GPIO5_IO02,
+	MX6_PAD_CSI0_PIXCLK__GPIO5_IO18,
+	MX6_PAD_CSI0_MCLK__GPIO5_IO19,
+	MX6_PAD_CSI0_DATA_EN__GPIO5_IO20,
+	MX6_PAD_CSI0_VSYNC__GPIO5_IO21,
+	MX6_PAD_CSI0_DAT12__GPIO5_IO30,
+	MX6_PAD_CSI0_DAT13__GPIO5_IO31,
+
+	MX6_PAD_CSI0_DAT14__GPIO6_IO00,
+	MX6_PAD_CSI0_DAT15__GPIO6_IO01,
+	MX6_PAD_NANDF_CLE__GPIO6_IO07,
+	MX6_PAD_NANDF_ALE__GPIO6_IO08,
+	MX6_PAD_NANDF_WP_B__GPIO6_IO09,
+	MX6_PAD_NANDF_RB0__GPIO6_IO10,
+	MX6_PAD_NANDF_CS0__GPIO6_IO11,
+	MX6_PAD_NANDF_CS1__GPIO6_IO14,
+	MX6_PAD_NANDF_CS2__GPIO6_IO15,
+	MX6_PAD_NANDF_CS3__GPIO6_IO16,
+	MX6_PAD_EIM_BCLK__GPIO6_IO31,
+
+	MX6_PAD_GPIO_16__GPIO7_IO11,
+	MX6_PAD_GPIO_17__GPIO7_IO12,
+	MX6_PAD_GPIO_18__GPIO7_IO13,
+};
+
+iomux_v3_cfg_t board_config_pads_bom[] = {
+	IOMUX_PADS(PAD_GPIO_5__GPIO1_IO05	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT4__GPIO5_IO22	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT5__GPIO5_IO23	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT6__GPIO5_IO24	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_CSI0_DAT7__GPIO5_IO25	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int board_config_gpio_bom[] = {
+	BRD_CFG0_GPIO,
+	BRD_CFG1_GPIO,
+	BRD_CFG2_GPIO,
+	BRD_CFG3_GPIO,
+	BRD_CFG4_GPIO,
+};
+
+iomux_v3_cfg_t board_config_pads_som[] = {
+	IOMUX_PADS(PAD_SD3_DAT5__GPIO7_IO00	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_SD3_DAT4__GPIO7_IO01	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+	IOMUX_PADS(PAD_GPIO_4__GPIO1_IO04	| MUX_PAD_CTRL(NO_PAD_CTRL)),
+};
+
+int board_config_gpio_som[] = {
+	BRD_CFG5_GPIO,
+	BRD_CFG6_GPIO,
+};
+
diff --git a/board/freescale/mx6_iwg15m_sm/plugin.S b/board/freescale/mx6_iwg15m_sm/plugin.S
new file mode 100644
index 0000000000..7df66d04cd
--- /dev/null
+++ b/board/freescale/mx6_iwg15m_sm/plugin.S
@@ -0,0 +1,531 @@
+/*
+ * Copyright (c) 2017 iWave Systems Technologies Pvt. Ltd.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+ 
+/*
+ * @file  plugin.S
+ * 
+ * @brief DDR settings for iwaves iMx6x SM SOMs 
+ *
+ * @ingroup DDR Setting
+ */
+
+#include <config.h>
+
+/* DDR script */
+.macro imx6dq_iwg15m_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x798]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x758]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x588]
+	str r1, [r0, #0x594]
+	str r1, [r0, #0x56c]
+	str r1, [r0, #0x578]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x57c]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x58c]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x59c]
+	str r1, [r0, #0x5a0]
+	str r1, [r0, #0x78c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x5a8]
+	str r1, [r0, #0x5b0]
+	str r1, [r0, #0x524]
+	str r1, [r0, #0x51c]
+	str r1, [r0, #0x518]
+	str r1, [r0, #0x50c]
+	str r1, [r0, #0x5b8]
+	str r1, [r0, #0x5c0]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x774]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x788]
+	str r1, [r0, #0x794]
+	str r1, [r0, #0x79c]
+	str r1, [r0, #0x7a0]
+	str r1, [r0, #0x7a4]
+	str r1, [r0, #0x7a8]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x5ac]
+	str r1, [r0, #0x5b4]
+	str r1, [r0, #0x528]
+	str r1, [r0, #0x520]
+	str r1, [r0, #0x514]
+	str r1, [r0, #0x510]
+	str r1, [r0, #0x5bc]
+	str r1, [r0, #0x5c4]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x00250025
+	str r2, [r0, #0x80c]
+	ldr r2, =0x00270022
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x00100024
+	str r2, [r1, #0x80c]
+	ldr r2, =0x000E0024
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x0330034C
+	str r2, [r0, #0x83c]
+	ldr r2, =0x033C0330
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x03440350
+	str r2, [r1, #0x83c]
+	ldr r2, =0x03340300
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x42383A3E
+	str r2, [r0, #0x848]
+	ldr r2, =0x40383844
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x34363C36
+	str r2, [r0, #0x850]
+	ldr r2, =0x40304A3C
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x00020036
+	str r2, [r0, #0x004]
+	ldr r2, =0x09444040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x54597955
+	str r2, [r0, #0x00c]
+	ldr r2, =0xFF328F64
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00591023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x02088032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x19408030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00007800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00022227
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x00025576
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6dl_iwg15m_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+	str r1, [r0, #0x4cc]
+	str r1, [r0, #0x4d0]
+	str r1, [r0, #0x4d4]
+	str r1, [r0, #0x4d8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x780]
+	str r1, [r0, #0x784]
+	str r1, [r0, #0x78c]
+	str r1, [r0, #0x748]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+	str r1, [r0, #0x480]
+	str r1, [r0, #0x484]
+	str r1, [r0, #0x488]
+	str r1, [r0, #0x48c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x004F0051
+	str r2, [r0, #0x80c]
+	ldr r2, =0x003F0044
+	str r2, [r0, #0x810]
+	ldr r1, =MMDC_P1_BASE_ADDR
+	ldr r2, =0x0027002B
+	str r2, [r1, #0x80c]
+	ldr r2, =0x002D0045
+	str r2, [r1, #0x810]
+
+	ldr r2, =0x02500258
+	str r2, [r0, #0x83c]
+	ldr r2, =0x02400240
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x02340240
+	str r2, [r1, #0x83c]
+	ldr r2, =0x02280230
+	str r2, [r1, #0x840]
+
+	ldr r2, =0x444A4E4A
+	str r2, [r0, #0x848]
+	ldr r2, =0x4C4C4E44
+	str r2, [r1, #0x848]
+
+	ldr r2, =0x34342A2E
+	str r2, [r0, #0x850]
+	ldr r2, =0x3434342C
+	str r2, [r1, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+	str r2, [r1, #0x81c]
+	str r2, [r1, #0x820]
+	str r2, [r1, #0x824]
+	str r2, [r1, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+	str r2, [r1, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F4352F3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66D8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x831A0000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x02008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x15208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00007800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00022227
+	str r2, [r0, #0x818]
+	str r2, [r1, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+
+.macro imx6solo_iwg15m_ddr_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0x000c0000
+	str r1, [r0, #0x774]
+	ldr r1, =0x00000000
+	str r1, [r0, #0x754]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4ac]
+	str r1, [r0, #0x4b0]
+	str r1, [r0, #0x464]
+	str r1, [r0, #0x490]
+	str r1, [r0, #0x74c]
+	str r1, [r0, #0x494]
+
+	ldr r1, =0x00000000
+	str r1, [r0, #0x4a0]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4b4]
+	str r1, [r0, #0x4b8]
+	str r1, [r0, #0x76c]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x750]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x4bc]
+	str r1, [r0, #0x4c0]
+	str r1, [r0, #0x4c4]
+	str r1, [r0, #0x4c8]
+
+	ldr r1, =0x00020000
+	str r1, [r0, #0x760]
+
+	ldr r1, =0x00000030
+	str r1, [r0, #0x764]
+	str r1, [r0, #0x770]
+	str r1, [r0, #0x778]
+	str r1, [r0, #0x77c]
+	str r1, [r0, #0x470]
+	str r1, [r0, #0x474]
+	str r1, [r0, #0x478]
+	str r1, [r0, #0x47c]
+
+	ldr r0, =MMDC_P0_BASE_ADDR
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0xa1390003
+	str r2, [r0, #0x800]
+
+	ldr r2, =0x0042004C
+	str r2, [r0, #0x80c]
+	ldr r2, =0x0035003F
+	str r2, [r0, #0x810]
+
+	ldr r2, =0x02400244
+	str r2, [r0, #0x83c]
+	ldr r2, =0x022C022C
+	str r2, [r0, #0x840]
+
+	ldr r2, =0x464A4E4C
+	str r2, [r0, #0x848]
+
+	ldr r2, =0x38343032
+	str r2, [r0, #0x850]
+
+	ldr r2, =0x33333333
+	str r2, [r0, #0x81c]
+	str r2, [r0, #0x820]
+	str r2, [r0, #0x824]
+	str r2, [r0, #0x828]
+
+	ldr r2, =0x00000800
+	str r2, [r0, #0x8b8]
+
+	ldr r2, =0x0002002D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00333040
+	str r2, [r0, #0x008]
+
+	ldr r2, =0x3F4352F3
+	str r2, [r0, #0x00c]
+	ldr r2, =0xB66D8B63
+	str r2, [r0, #0x010]
+
+	ldr r2, =0x01FF00DB
+	str r2, [r0, #0x014]
+	ldr r2, =0x00011740
+	str r2, [r0, #0x018]
+
+	ldr r2, =0x00008000
+	str r2, [r0, #0x01c]
+	ldr r2, =0x000026d2
+	str r2, [r0, #0x02c]
+	ldr r2, =0x00431023
+	str r2, [r0, #0x030]
+	ldr r2, =0x00000027
+	str r2, [r0, #0x040]
+
+	ldr r2, =0x83190000
+	str r2, [r0, #0x000]
+
+	ldr r2, =0x02008032
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00008033
+	str r2, [r0, #0x01c]
+	ldr r2, =0x00048031
+	str r2, [r0, #0x01c]
+	ldr r2, =0x15208030
+	str r2, [r0, #0x01c]
+	ldr r2, =0x04008040
+	str r2, [r0, #0x01c]
+
+	ldr r2, =0x00007800
+	str r2, [r0, #0x020]
+	ldr r2, =0x00022227
+	str r2, [r0, #0x818]
+	ldr r2, =0x0002556D
+	str r2, [r0, #0x004]
+	ldr r2, =0x00011006
+	str r2, [r0, #0x404]
+	ldr r2, =0x00000000
+	str r2, [r0, #0x01c]
+.endm
+.macro imx6_clock_gating
+	ldr r0, =CCM_BASE_ADDR
+	ldr r1, =0x00C03F3F
+	str r1, [r0, #0x068]
+	ldr r1, =0x0030FC03
+	str r1, [r0, #0x06c]
+	ldr r1, =0x0FFFC000
+	str r1, [r0, #0x070]
+	ldr r1, =0x3FF00000
+	str r1, [r0, #0x074]
+	ldr r1, =0x00FFF300
+	str r1, [r0, #0x078]
+	ldr r1, =0x0F0000F3
+	str r1, [r0, #0x07c]
+	ldr r1, =0x000003FF
+	str r1, [r0, #0x080]
+.endm
+
+.macro imx6_qos_setting
+	ldr r0, =IOMUXC_BASE_ADDR
+	ldr r1, =0xF00000CF
+	str r1, [r0, #0x10]
+
+	ldr r1, =0x007F007F
+	str r1, [r0, #0x18]
+	str r1, [r0, #0x1c]
+.endm
+
+.macro imx6_ddr_setting
+	ldr r0, =ANATOP_BASE_ADDR
+	ldr r1, [r0,#0x260]
+	ldr r3,=0xff0000
+	and r1,r1,r3
+	cmp r1,#0x630000
+	beq quad_cpu
+
+	ldr r0, =OCOTP_BASE_ADDR
+	ldr r1, [r0,#0x430]
+	ldr r3,=0x100000
+	and r1,r1,r3
+	cmp r1,#0x100000
+	beq solo_cpu	
+	cmp r1,#0x0
+	beq duallite_cpu
+
+solo_cpu:
+	imx6solo_iwg15m_ddr_setting
+	b common_ddr
+
+duallite_cpu:
+	imx6dl_iwg15m_ddr_setting
+	b common_ddr
+
+quad_cpu:
+	imx6dq_iwg15m_ddr_setting
+	b common_ddr
+
+common_ddr:
+.endm
+
+/* include the common plugin code here */
+#include <asm/arch/mx6_plugin.S>
diff --git a/drivers/net/fec_mxc.c b/drivers/net/fec_mxc.c
index cc23aeacf5..885780505d 100644
--- a/drivers/net/fec_mxc.c
+++ b/drivers/net/fec_mxc.c
@@ -1171,6 +1171,31 @@ int fecmxc_initialize_multi(bd_t *bd, int dev_id, int phy_id, uint32_t addr)
 	bus = fec_get_miibus((ulong)base_mii, dev_id);
 	if (!bus)
 		return -ENOMEM;
+
+#ifdef IWCONFIG_MX6_IWG15
+	/* IWG15: Discovering Phy address*/
+	unsigned int addrs;
+	for (addrs = 0; addrs < 0x20; addrs++)
+	{
+		int id = 0;
+		int val;
+		val = fec_phy_read(bus, addrs, 0, 0x03);
+		id = val;
+		if (id == 0xFFFF)
+			continue;
+
+		val = fec_phy_read(bus, addrs, 0, 0x2);
+		if (val == 0xFFFF)
+			continue;
+
+		id |= val << 16;
+
+		printf("PHY indentify @ 0x%x = 0x%08x\n", addrs, id);
+
+		phy_id = addrs;
+	}
+#endif
+
 #ifdef CONFIG_PHYLIB
 	phydev = phy_find_by_mask(bus, 1 << phy_id, PHY_INTERFACE_MODE_RGMII);
 	if (!phydev) {
